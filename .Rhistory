
#   rb.raster[!is.na(rb.raster)] <- 1
#   plot(rb.raster)
#   for(i in 1:nrow(rb$lines.df)){
#     abline(rb$lines.df[i,2], rb$lines.df[i,1])
#   }
grid.arrange(rb$d.plot.sp1.vs.sp2, rb$env.d.plot.sp1.vs.sp2,
rb$i.plot.sp1.vs.sp2, rb$env.i.plot.sp1.vs.sp2,
rb$cor.plot.sp1.vs.sp2, rb$env.cor.plot.sp1.vs.sp2, ncol = 2)
grid.arrange(rb$d.plot.sp1.vs.ribbon, rb$env.d.plot.sp1.vs.ribbon,
rb$i.plot.sp1.vs.ribbon, rb$env.i.plot.sp1.vs.ribbon,
rb$cor.plot.sp1.vs.ribbon, rb$env.cor.plot.sp1.vs.ribbon, ncol = 2)
grid.arrange(rb$d.plot.sp2.vs.ribbon, rb$env.d.plot.sp2.vs.ribbon,
rb$i.plot.sp2.vs.ribbon, rb$env.i.plot.sp2.vs.ribbon,
rb$cor.plot.sp2.vs.ribbon, rb$env.cor.plot.sp2.vs.ribbon, ncol = 2)
grid.arrange(rb$d.plot.outside.vs.ribbon, rb$env.d.plot.outside.vs.ribbon,
rb$i.plot.outside.vs.ribbon, rb$env.i.plot.outside.vs.ribbon,
rb$cor.plot.outside.vs.ribbon, rb$env.cor.plot.outside.vs.ribbon, ncol = 2)
}
rbr
warnings()
library(ENMTools)
rbr <- rangebreak.ribbon(ahli, allogus, ribbon, env, type = "dm", width = 0.3, nreps = 19)
library(ENMTools)
rbr <- rangebreak.ribbon(ahli, allogus, ribbon, env, type = "dm", width = 0.3, nreps = 19)
library(ENMTools)
rbr <- rangebreak.ribbon(ahli, allogus, ribbon, env, type = "dm", width = 0.3, nreps = 19)
#' rangebreak.ribbon Conduct a ribbon rangebreak test as described in Glor and Warren 2011.
#'
>>>>>>> Stashed changes
#'
#' @param formula Standard GLM formula
#' @param species An enmtools.species object
#' @param env A raster or raster stack of environmental data.
#' @param test.prop Proportion of data to withhold for model evaluation
#' @param ... Arguments to be passed to glm()
#'
#' @export enmtools.glm
#' @export print.enmtools.glm
#' @export summary.enmtools.glm
#' @export plot.enmtools.glm
enmtools.glm <- function(f, species, env, test.prop = 0, ...){
species <- check.bg(species, env, ...)
glm.precheck(f, species, env)
test.data <- NA
test.evaluation <- NA
if(test.prop > 0 & test.prop < 1){
test.inds <- sample(1:nrow(species$presence.points), ceiling(nrow(species$presence.points) * test.prop))
test.data <- species$presence.points[test.inds,]
species$presence.points <- species$presence.points[-test.inds,]
}
### Add env data
species <- add.env(species, env)
# Recast this formula so that the response variable is named "presence"
# regardless of what was passed.
f <- reformulate(attr(delete.response(terms(f)), "term.labels"), response = "presence")
analysis.df <- rbind(species$presence.points, species$background.points)
analysis.df$presence <- c(rep(1, nrow(species$presence.points)), rep(0, nrow(species$background.points)))
this.glm <- glm(f, analysis.df[,-c(1,2)], family="binomial", ...)
suitability <- predict(env, this.glm, type = "response")
model.evaluation <- evaluate(species$presence.points[,1:2], species$background.points[,1:2],
this.glm, env)
if(test.prop > 0 & test.prop < 1){
test.evaluation <- evaluate(test.data, species$background.points[,1:2],
this.glm, env)
}
output <- list(formula = f,
analysis.df = analysis.df,
test.data = test.data,
test.prop = test.prop,
model = this.glm,
training.evaluation = model.evaluation,
test.evaluation = test.evaluation,
suitability = suitability)
class(output) <- c("enmtools.glm", "enmtools.model")
# Doing response plots for each variable.  Doing this bit after creating
# the output object because plot.response expects an enmtools.model object
response.plots <- list()
for(i in names(env)){
response.plots[[i]] <- plot.response(output, env, i)
}
output[["response.plots"]] <- response.plots
return(output)
}
# Summary for objects of class enmtools.glm
summary.enmtools.glm <- function(this.glm){
cat("\n\nFormula:  ")
print(this.glm$formula)
cat("\n\nData table (top ten lines): ")
print(kable(head(this.glm$analysis.df, 10)))
cat("\n\nModel:  ")
print(summary(this.glm$model))
cat("\n\nModel fit (training data):  ")
print(this.glm$training.evaluation)
cat("\n\nProportion of data wittheld for model fitting:  ")
cat(this.glm$test.prop)
cat("\n\nModel fit (test data):  ")
print(this.glm$test.evaluation)
cat("\n\nSuitability:  \n")
print(this.glm$suitability)
plot(this.glm)
}
# Print method for objects of class enmtools.glm
print.enmtools.glm <- function(this.glm){
print(summary(this.glm))
}
# Plot method for objects of class enmtools.glm
plot.enmtools.glm <- function(this.glm){
suit.points <- data.frame(rasterToPoints(this.glm$suitability))
colnames(suit.points) <- c("Longitude", "Latitude", "Suitability")
suit.plot <- ggplot(data = suit.points, aes(y = Latitude, x = Longitude)) +
geom_raster(aes(fill = Suitability)) +
scale_fill_viridis(option = "C", guide = guide_colourbar(title = "Suitability")) +
coord_fixed() + theme_classic() +
geom_point(data = this.glm$analysis.df, aes(x = Longitude, y = Latitude),
pch = 21, fill = "white", color = "black", size = 2)
if(!is.na(this.glm$test.data)){
suit.plot <- suit.plot + geom_point(data = this.glm$test.data, aes(x = Longitude, y = Latitude),
pch = 21, fill = "green", color = "black", size = 2)
}
return(suit.plot)
}
# Function for checking data prior to running enmtools.glm
glm.precheck <- function(f, species, env){
# Check to see if the function is the right class
if(!inherits(f, "formula")){
stop("Argument \'formula\' must contain an R formula object!")
}
### Check to make sure the data we need is there
if(!inherits(species, "enmtools.species")){
stop("Argument \'species\' must contain an enmtools.species object!")
}
check.species(species)
if(!inherits(species$presence.points, "data.frame")){
stop("Species presence.points do not appear to be an object of class data.frame")
}
if(!inherits(species$background.points, "data.frame")){
stop("Species background.points do not appear to be an object of class data.frame")
}
if(!inherits(env, c("raster", "RasterLayer", "RasterStack"))){
stop("No environmental rasters were supplied!")
}
if(ncol(species$presence.points) != 2){
stop("Species presence points do not contain longitude and latitude data!")
}
if(ncol(species$background.points) != 2){
stop("Species background points do not contain longitude and latitude data!")
}
}
ahli.glm
head(ahli.glm$analysis.df)
#' Takes an emtools.species object with presence and background points, and builds a GLM
#'
#' @param formula Standard GLM formula
#' @param species An enmtools.species object
#' @param env A raster or raster stack of environmental data.
#' @param test.prop Proportion of data to withhold for model evaluation
#' @param ... Arguments to be passed to glm()
#'
#' @export enmtools.glm
#' @export print.enmtools.glm
#' @export summary.enmtools.glm
#' @export plot.enmtools.glm
enmtools.glm <- function(f, species, env, test.prop = 0, ...){
species <- check.bg(species, env, ...)
glm.precheck(f, species, env)
test.data <- NA
test.evaluation <- NA
if(test.prop > 0 & test.prop < 1){
test.inds <- sample(1:nrow(species$presence.points), ceiling(nrow(species$presence.points) * test.prop))
test.data <- species$presence.points[test.inds,]
species$presence.points <- species$presence.points[-test.inds,]
}
### Add env data
species <- add.env(species, env)
# Recast this formula so that the response variable is named "presence"
# regardless of what was passed.
f <- reformulate(attr(delete.response(terms(f)), "term.labels"), response = "presence")
analysis.df <- rbind(species$presence.points, species$background.points)
analysis.df$presence <- c(rep(1, nrow(species$presence.points)), rep(0, nrow(species$background.points)))
this.glm <- glm(f, analysis.df[,-c(1,2)], family="binomial", ...)
suitability <- predict(env, this.glm, type = "response")
model.evaluation <- evaluate(species$presence.points[,1:2], species$background.points[,1:2],
this.glm, env)
if(test.prop > 0 & test.prop < 1){
test.evaluation <- evaluate(test.data, species$background.points[,1:2],
this.glm, env)
}
output <- list(formula = f,
analysis.df = analysis.df,
test.data = test.data,
test.prop = test.prop,
model = this.glm,
training.evaluation = model.evaluation,
test.evaluation = test.evaluation,
suitability = suitability)
class(output) <- c("enmtools.glm", "enmtools.model")
# Doing response plots for each variable.  Doing this bit after creating
# the output object because plot.response expects an enmtools.model object
response.plots <- list()
for(i in names(env)){
response.plots[[i]] <- plot.response(output, env, i)
}
output[["response.plots"]] <- response.plots
return(output)
}
# Summary for objects of class enmtools.glm
summary.enmtools.glm <- function(this.glm){
cat("\n\nFormula:  ")
print(this.glm$formula)
cat("\n\nData table (top ten lines): ")
print(kable(head(this.glm$analysis.df, 10)))
cat("\n\nModel:  ")
print(summary(this.glm$model))
cat("\n\nModel fit (training data):  ")
print(this.glm$training.evaluation)
cat("\n\nProportion of data wittheld for model fitting:  ")
cat(this.glm$test.prop)
cat("\n\nModel fit (test data):  ")
print(this.glm$test.evaluation)
cat("\n\nSuitability:  \n")
print(this.glm$suitability)
plot(this.glm)
}
# Print method for objects of class enmtools.glm
print.enmtools.glm <- function(this.glm){
print(summary(this.glm))
}
# Plot method for objects of class enmtools.glm
plot.enmtools.glm <- function(this.glm){
suit.points <- data.frame(rasterToPoints(this.glm$suitability))
colnames(suit.points) <- c("Longitude", "Latitude", "Suitability")
suit.plot <- ggplot(data = suit.points, aes(y = Latitude, x = Longitude)) +
geom_raster(aes(fill = Suitability)) +
scale_fill_viridis(option = "C", guide = guide_colourbar(title = "Suitability")) +
coord_fixed() + theme_classic() +
geom_point(data = this.glm$analysis.df[this.glm$analysis.df$presence == 1,], aes(x = Longitude, y = Latitude),
pch = 21, fill = "white", color = "black", size = 2)
if(!is.na(this.glm$test.data)){
suit.plot <- suit.plot + geom_point(data = this.glm$test.data, aes(x = Longitude, y = Latitude),
pch = 21, fill = "green", color = "black", size = 2)
}
return(suit.plot)
}
# Function for checking data prior to running enmtools.glm
glm.precheck <- function(f, species, env){
# Check to see if the function is the right class
if(!inherits(f, "formula")){
stop("Argument \'formula\' must contain an R formula object!")
}
### Check to make sure the data we need is there
if(!inherits(species, "enmtools.species")){
stop("Argument \'species\' must contain an enmtools.species object!")
}
check.species(species)
if(!inherits(species$presence.points, "data.frame")){
stop("Species presence.points do not appear to be an object of class data.frame")
}
if(!inherits(species$background.points, "data.frame")){
stop("Species background.points do not appear to be an object of class data.frame")
}
if(!inherits(env, c("raster", "RasterLayer", "RasterStack"))){
stop("No environmental rasters were supplied!")
}
if(ncol(species$presence.points) != 2){
stop("Species presence points do not contain longitude and latitude data!")
}
if(ncol(species$background.points) != 2){
stop("Species background points do not contain longitude and latitude data!")
}
}
#' Takes an emtools.species object with presence and background points, and builds a GLM
#'
#' @param formula Standard GLM formula
#' @param species An enmtools.species object
#' @param env A raster or raster stack of environmental data.
#' @param test.prop Proportion of data to withhold for model evaluation
#' @param ... Arguments to be passed to glm()
#'
#' @export enmtools.glm
#' @export print.enmtools.glm
#' @export summary.enmtools.glm
#' @export plot.enmtools.glm
enmtools.glm <- function(f, species, env, test.prop = 0, ...){
species <- check.bg(species, env, ...)
glm.precheck(f, species, env)
test.data <- NA
test.evaluation <- NA
if(test.prop > 0 & test.prop < 1){
test.inds <- sample(1:nrow(species$presence.points), ceiling(nrow(species$presence.points) * test.prop))
test.data <- species$presence.points[test.inds,]
species$presence.points <- species$presence.points[-test.inds,]
}
### Add env data
species <- add.env(species, env)
# Recast this formula so that the response variable is named "presence"
# regardless of what was passed.
f <- reformulate(attr(delete.response(terms(f)), "term.labels"), response = "presence")
analysis.df <- rbind(species$presence.points, species$background.points)
analysis.df$presence <- c(rep(1, nrow(species$presence.points)), rep(0, nrow(species$background.points)))
this.glm <- glm(f, analysis.df[,-c(1,2)], family="binomial", ...)
suitability <- predict(env, this.glm, type = "response")
model.evaluation <- evaluate(species$presence.points[,1:2], species$background.points[,1:2],
this.glm, env)
if(test.prop > 0 & test.prop < 1){
test.evaluation <- evaluate(test.data, species$background.points[,1:2],
this.glm, env)
}
output <- list(formula = f,
analysis.df = analysis.df,
test.data = test.data,
test.prop = test.prop,
model = this.glm,
training.evaluation = model.evaluation,
test.evaluation = test.evaluation,
suitability = suitability)
class(output) <- c("enmtools.glm", "enmtools.model")
# Doing response plots for each variable.  Doing this bit after creating
# the output object because plot.response expects an enmtools.model object
response.plots <- list()
for(i in names(env)){
response.plots[[i]] <- plot.response(output, env, i)
}
output[["response.plots"]] <- response.plots
return(output)
}
# Summary for objects of class enmtools.glm
summary.enmtools.glm <- function(this.glm){
cat("\n\nFormula:  ")
print(this.glm$formula)
cat("\n\nData table (top ten lines): ")
print(kable(head(this.glm$analysis.df, 10)))
cat("\n\nModel:  ")
print(summary(this.glm$model))
cat("\n\nModel fit (training data):  ")
print(this.glm$training.evaluation)
cat("\n\nProportion of data wittheld for model fitting:  ")
cat(this.glm$test.prop)
cat("\n\nModel fit (test data):  ")
print(this.glm$test.evaluation)
cat("\n\nSuitability:  \n")
print(this.glm$suitability)
plot(this.glm)
}
# Print method for objects of class enmtools.glm
print.enmtools.glm <- function(this.glm){
print(summary(this.glm))
}
# Plot method for objects of class enmtools.glm
plot.enmtools.glm <- function(this.glm){
suit.points <- data.frame(rasterToPoints(this.glm$suitability))
colnames(suit.points) <- c("Longitude", "Latitude", "Suitability")
suit.plot <- ggplot(data = suit.points, aes(y = Latitude, x = Longitude)) +
geom_raster(aes(fill = Suitability)) +
scale_fill_viridis(option = "C", guide = guide_colourbar(title = "Suitability")) +
coord_fixed() + theme_classic() +
geom_point(data = this.glm$analysis.df[this.glm$analysis.df$presence == 1,], aes(x = Longitude, y = Latitude),
pch = 21, fill = "white", color = "black", size = 2)
if(!is.na(this.glm$test.data)){
suit.plot <- suit.plot + geom_point(data = this.glm$test.data, aes(x = Longitude, y = Latitude),
pch = 21, fill = "green", color = "black", size = 2)
}
return(suit.plot)
}
# Function for checking data prior to running enmtools.glm
glm.precheck <- function(f, species, env){
# Check to see if the function is the right class
if(!inherits(f, "formula")){
stop("Argument \'formula\' must contain an R formula object!")
}
### Check to make sure the data we need is there
if(!inherits(species, "enmtools.species")){
stop("Argument \'species\' must contain an enmtools.species object!")
}
check.species(species)
if(!inherits(species$presence.points, "data.frame")){
stop("Species presence.points do not appear to be an object of class data.frame")
}
if(!inherits(species$background.points, "data.frame")){
stop("Species background.points do not appear to be an object of class data.frame")
}
if(!inherits(env, c("raster", "RasterLayer", "RasterStack"))){
stop("No environmental rasters were supplied!")
}
if(ncol(species$presence.points) != 2){
stop("Species presence points do not contain longitude and latitude data!")
}
if(ncol(species$background.points) != 2){
stop("Species background points do not contain longitude and latitude data!")
}
}
ahli.glm
#' Takes an emtools.species object with presence and background points, and builds a maxent model
#'
#' @param formula Standard R formula
#' @param species An enmtools.species object
#' @param env A raster or raster stack of environmental data.
#' @param test.prop Proportion of data to withhold for model evaluation
#' @param ... Arguments to be passed to maxent()
#'
#' @export enmtools.maxent
#' @export print.enmtools.maxent
#' @export summary.enmtools.maxent
#' @export plot.enmtools.maxent
enmtools.maxent <- function(species, env, test.prop = 0, ...){
species <- check.bg(species, env, ...)
maxent.precheck(f, species, env)
test.data <- NA
test.evaluation <- NA
if(test.prop > 0 & test.prop < 1){
test.inds <- sample(1:nrow(species$presence.points), ceiling(nrow(species$presence.points) * test.prop))
test.data <- species$presence.points[test.inds,]
species$presence.points <- species$presence.points[-test.inds,]
}
analysis.df <- rbind(species$presence.points, species$background.points)
analysis.df$presence <- c(rep(1, nrow(species$presence.points)), rep(0, nrow(species$background.points)))
this.mx <- maxent(env, p = analysis.df[analysis.df$presence == 1,1:2], a = analysis.df[analysis.df$presence == 0,1:2], ...)
model.evaluation <- evaluate(species$presence.points[,1:2], species$background.points[,1:2],
this.mx, env)
if(test.prop > 0 & test.prop < 1){
test.evaluation <- evaluate(test.data, species$background.points[,1:2],
this.mx, env)
}
suitability <- predict(env, this.mx, type = "response")
output <- list(analysis.df = analysis.df,
test.data = test.data,
test.prop = test.prop,
model = this.mx,
training.evaluation = model.evaluation,
test.evaluation = test.evaluation,
suitability = suitability)
class(output) <- c("enmtools.maxent", "enmtools.model")
# Doing response plots for each variable.  Doing this bit after creating
# the output object because plot.response expects an enmtools.model object
response.plots <- list()
for(i in names(env)){
response.plots[[i]] <- plot.response(output, env, i)
}
output[["response.plots"]] <- response.plots
return(output)
}
# Summary for objects of class enmtools.maxent
summary.enmtools.maxent <- function(this.maxent){
cat("\n\nData table (top ten lines): ")
print(kable(head(this.maxent$analysis.df, 10)))
cat("\n\nModel:  ")
print(summary(this.maxent$model))
cat("\n\nModel fit (training data):  ")
print(this.maxent$training.evaluation)
cat("\n\nProportion of data wittheld for model fitting:  ")
cat(this.maxent$test.prop)
cat("\n\nModel fit (test data):  ")
print(this.maxent$test.evaluation)
cat("\n\nSuitability:  \n")
print(this.maxent$suitability)
plot(this.maxent)
}
# Print method for objects of class enmtools.maxent
print.enmtools.maxent <- function(this.maxent){
summary(this.maxent)
}
# Plot method for objects of class enmtools.maxent
plot.enmtools.maxent <- function(this.maxent){
suit.points <- data.frame(rasterToPoints(this.maxent$suitability))
colnames(suit.points) <- c("Longitude", "Latitude", "Suitability")
suit.plot <- ggplot(data = suit.points, aes(y = Latitude, x = Longitude)) +
geom_raster(aes(fill = Suitability)) +
scale_fill_viridis(option = "C", guide = guide_colourbar(title = "Suitability")) +
coord_fixed() + theme_classic() +
geom_point(data = this.maxent$analysis.df[this.maxent$analysis.df$presence ==1,], aes(x = Longitude, y = Latitude),
pch = 21, fill = "white", color = "black", size = 2)
if(!is.na(this.maxent$test.data)){
suit.plot <- suit.plot + geom_point(data = this.maxent$test.data, aes(x = Longitude, y = Latitude),
pch = 21, fill = "green", color = "black", size = 2)
}
return(suit.plot)
}
# Function for checking data prior to running enmtools.maxent
maxent.precheck <- function(f, species, env){
### Check to make sure the data we need is there
if(!inherits(species, "enmtools.species")){
stop("Argument \'species\' must contain an enmtools.species object!")
}
check.species(species)
if(!inherits(species$presence.points, "data.frame")){
stop("Species presence.points do not appear to be an object of class data.frame")
}
if(!inherits(species$background.points, "data.frame")){
stop("Species background.points do not appear to be an object of class data.frame")
}
if(!inherits(env, c("raster", "RasterLayer", "RasterStack"))){
stop("No environmental rasters were supplied!")
}
if(ncol(species$presence.points) != 2){
stop("Species presence points do not contain longitude and latitude data!")
}
if(ncol(species$background.points) != 2){
stop("Species background points do not contain longitude and latitude data!")
}
}
library(ENMTools)
<<<<<<< Updated upstream
ahli.mx <- enmtools.maxent(ahli, env, test.prop = 0.2)
=======
library(ENMTools)
rbr <- rangebreak.ribbon(ahli, allogus, ribbon, env, type = "dm", width = 0.3, nreps = 19)
rbr
rbr <- rangebreak.ribbon(ahli, allogus, ribbon, env, type = "dm", width = 0.3, nreps = 19, cor.method = "spearman")
setwd("~/GitHub/ENMTools/test")
library(ENMTools)
env.files <- list.files(path = "testdata/", pattern = "pc", full.names = TRUE)
env <- stack(env.files)
names(env) <- c("layer.1", "layer.2", "layer.3", "layer.4")
env <- setMinMax(env)
ahli <- enmtools.species()
check.species(ahli)
allogus <- enmtools.species(species.name = "allogus", presence.points = read.csv("testdata/allogus.csv")[,3:4])
check.species(allogus)
ahli <- enmtools.species(species.name = "ahli", presence.points = read.csv("testdata/ahli.csv")[,3:4])
check.species(ahli)
ahli$range <- background.raster.buffer(ahli$presence.points, 50000, mask = env)
allogus$range <- background.raster.buffer(allogus$presence.points, 50000, mask = env)
ahli$background.points <- background.points.buffer(points = ahli$presence.points,radius = 20000, n = 1000, mask = env[[1]])
allogus$background.points <- background.points.buffer(points = allogus$presence.points,radius = 20000, n = 1000, mask = env[[1]])
# Should fail because presence and background have different col names
check.species(ahli)
colnames(ahli$background.points) <- colnames(ahli$presence.points)
colnames(allogus$background.points) <- colnames(allogus$presence.points)
two.anoles <- enmtools.clade(list(ahli, allogus))
two.anoles
check.clade(two.anoles)
summary(ahli)
print(ahli)
plot(ahli)
summary(two.anoles)
plot(two.anoles)
ahli.glm <- enmtools.glm(pres ~ layer.1 + layer.2 + layer.3 + layer.4, ahli, env, test.prop = 0.2)
ahli.glm
ahli.glm
ahli.glm$response.plots
onevar.glm <- enmtools.glm(pres ~ layer.1, ahli, env, test.prop = 0.2)
onevar.glm
onevar.glm$response.plots
help(env.overlap)
rbl.glm <- rangebreak.linear(ahli, allogus, env, type = "bc", f = pres ~ layer.1 + layer.2 + layer.3 + layer.4, nreps = 4)
knit(input="Readme.Rmd", output = "readme.md")
setwd("~/GitHub/ENMTools/test")
knit(input="Readme.Rmd", output = "readme.md")
setwd("~/GitHub/ENMTools/")
knit(input="Readme.Rmd", output = "readme.md")
rbl.glm
rbl.glm$replicate.models
.
knit(input="Readme.Rmd", output = "readme.md")
>>>>>>> Stashed changes
