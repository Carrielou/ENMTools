<<<<<<< HEAD
#' @param species.2 An enmtools.species object from which background will be sampled.
#' @param env A RasterLayer or RasterStack object containing environmental data
#' @param type The type of model to construct, currently accepts "glm", "mx", "bc", or "dm"
#' @param f A function to use for model fitting.  Only required for GLM models at the moment.
#' @param nreps Number of replicates to perform
#' @param ... Additional arguments to be passed to model fitting functions.
#'
#' @return results A list containing replicates, models for the empirical data, and summary statistics and plots.
#'
#' @keywords background, equivalency, enmtools, hypothesis testing
#'
#' @export background.test
#' @export background.precheck
#' @export print.background.test
#' @export summary.background.test
#' @export plot.background.test
#'
#' @examples
#' background.test(ahli, allogus, env, type = "glm", f = layer.1 + layer.2 + layer.3, nreps = 10, type = "asymmetric", ...)
#'
background.test <- function(species.1, species.2, env, type, f = NULL, nreps = 99, test.type = "asymmetric", ...){
#   if(type == "mx"){
#     bg.source = "range"
#   }
background.precheck(species.1, species.2, env, type, f, nreps, test.type)
if(type == "glm"){
cat("\nBuilding empirical models...\n")
empirical.species.1.model <- enmtools.glm(f, species.1, env, ...)
empirical.species.2.model <- enmtools.glm(f, species.2, env, ...)
empirical.overlap <- raster.overlap(empirical.species.1.model, empirical.species.2.model)
reps.overlap <- unlist(empirical.overlap)
cat("\nBuilding replicate models...\n")
for(i in 1:nreps){
cat(paste("\nReplicate", i, "...\n"))
rep.species.1 <- species.1
rep.species.2 <- species.2
if(test.type == "symmetric"){
#background sampling for species 1, only run when we're doing a symmetric test
combined.points <- rbind(rep.species.1$presence.points, rep.species.1$background.points)
sample.vector <- sample(nrow(combined.points))
combined.points <- combined.points[sample.vector,]
rep.species.1$presence.points <- combined.points[1:nrow(species.1$presence.points),]
rep.species.1$background.points <- combined.points[(nrow(species.1$presence.points) + 1):nrow(combined.points),]
}
# Background sampling for species 2, run regardless of the type of test
combined.points <- rbind(rep.species.2$presence.points, rep.species.2$background.points)
sample.vector <- sample(nrow(combined.points))
combined.points <- combined.points[sample.vector,]
rep.species.2$presence.points <- combined.points[1:nrow(species.2$presence.points),]
rep.species.2$background.points <- combined.points[(nrow(species.2$presence.points) + 1):nrow(combined.points),]
# Building the models for reps
rep.species.1.glm <- enmtools.glm(f, rep.species.1, env, ...)
rep.species.2.glm <- enmtools.glm(f, rep.species.2, env, ...)
# Appending to results
reps.overlap <- rbind(reps.overlap, unlist(raster.overlap(rep.species.1.glm, rep.species.2.glm)))
}
}
if(type == "mx"){
cat("\nBuilding empirical models...\n")
empirical.species.1.model <- enmtools.maxent(species.1, env, ...)
empirical.species.2.model <- enmtools.maxent(species.2, env, ...)
empirical.overlap <- raster.overlap(empirical.species.1.model, empirical.species.2.model)
reps.overlap <- unlist(empirical.overlap)
cat("\nBuilding replicate models...\n")
for(i in 1:nreps){
cat(paste("\nReplicate", i, "...\n"))
rep.species.1 <- species.1
rep.species.2 <- species.2
if(test.type == "symmetric"){
#background sampling for species 1, only run when we're doing a symmetric test
combined.points <- rbind(rep.species.1$presence.points, rep.species.1$background.points)
sample.vector <- sample(nrow(combined.points))
combined.points <- combined.points[sample.vector,]
rep.species.1$presence.points <- combined.points[1:nrow(species.1$presence.points),]
rep.species.1$background.points <- combined.points[(nrow(species.1$presence.points) + 1):nrow(combined.points),]
}
# Background sampling for species 2, run regardless of the type of test
combined.points <- rbind(rep.species.2$presence.points, rep.species.2$background.points)
sample.vector <- sample(nrow(combined.points))
combined.points <- combined.points[sample.vector,]
rep.species.2$presence.points <- combined.points[1:nrow(species.2$presence.points),]
rep.species.2$background.points <- combined.points[(nrow(species.2$presence.points) + 1):nrow(combined.points),]
rep.species.1.mx <- enmtools.maxent(rep.species.1, env, ...)
rep.species.2.mx <- enmtools.maxent(rep.species.2, env, ...)
# Appending to results
reps.overlap <- rbind(reps.overlap, unlist(raster.overlap(rep.species.1.mx, rep.species.2.mx)))
}
}
if(type == "bc"){
cat("\nBuilding empirical models...\n")
empirical.species.1.model <- enmtools.bc(species.1, env, ...)
empirical.species.2.model <- enmtools.bc(species.2, env, ...)
empirical.overlap <- raster.overlap(empirical.species.1.model, empirical.species.2.model)
reps.overlap <- unlist(empirical.overlap)
cat("\nBuilding replicate models...\n")
for(i in 1:nreps){
cat(paste("\nReplicate", i, "...\n"))
rep.species.1 <- species.1
rep.species.2 <- species.2
if(test.type == "symmetric"){
#background sampling for species 1, only run when we're doing a symmetric test
combined.points <- rbind(rep.species.1$presence.points, rep.species.1$background.points)
sample.vector <- sample(nrow(combined.points))
combined.points <- combined.points[sample.vector,]
rep.species.1$presence.points <- combined.points[1:nrow(species.1$presence.points),]
rep.species.1$background.points <- combined.points[(nrow(species.1$presence.points) + 1):nrow(combined.points),]
}
# Background sampling for species 2, run regardless of the type of test
combined.points <- rbind(rep.species.2$presence.points, rep.species.2$background.points)
sample.vector <- sample(nrow(combined.points))
combined.points <- combined.points[sample.vector,]
rep.species.2$presence.points <- combined.points[1:nrow(species.2$presence.points),]
rep.species.2$background.points <- combined.points[(nrow(species.2$presence.points) + 1):nrow(combined.points),]
rep.species.1.bc <- enmtools.bc(rep.species.1, env, ...)
rep.species.2.bc <- enmtools.bc(rep.species.2, env, ...)
# Appending to results
reps.overlap <- rbind(reps.overlap, unlist(raster.overlap(rep.species.1.bc, rep.species.2.bc)))
}
}
if(type == "dm"){
cat("\nBuilding empirical models...\n")
empirical.species.1.model <- enmtools.dm(species.1, env, ...)
empirical.species.2.model <- enmtools.dm(species.2, env, ...)
empirical.overlap <- raster.overlap(empirical.species.1.model, empirical.species.2.model)
reps.overlap <- unlist(empirical.overlap)
cat("\nBuilding replicate models...\n")
for(i in 1:nreps){
cat(paste("\nReplicate", i, "...\n"))
rep.species.1 <- species.1
rep.species.2 <- species.2
if(test.type == "symmetric"){
#background sampling for species 1, only run when we're doing a symmetric test
combined.points <- rbind(rep.species.1$presence.points, rep.species.1$background.points)
sample.vector <- sample(nrow(combined.points))
combined.points <- combined.points[sample.vector,]
rep.species.1$presence.points <- combined.points[1:nrow(species.1$presence.points),]
rep.species.1$background.points <- combined.points[(nrow(species.1$presence.points) + 1):nrow(combined.points),]
}
# Background sampling for species 2, run regardless of the type of test
combined.points <- rbind(rep.species.2$presence.points, rep.species.2$background.points)
sample.vector <- sample(nrow(combined.points))
combined.points <- combined.points[sample.vector,]
rep.species.2$presence.points <- combined.points[1:nrow(species.2$presence.points),]
rep.species.2$background.points <- combined.points[(nrow(species.2$presence.points) + 1):nrow(combined.points),]
rep.species.1.dm <- enmtools.dm(rep.species.1, env, ...)
rep.species.2.dm <- enmtools.dm(rep.species.2, env, ...)
# Appending to results
reps.overlap <- rbind(reps.overlap, unlist(raster.overlap(rep.species.1.dm, rep.species.2.dm)))
}
}
rownames(reps.overlap) <- c("empirical", paste("rep", 1:nreps))
p.values <- apply(reps.overlap, 2, function(x) 1 - mean(x > x[1]))
d.plot <- qplot(reps.overlap[2:nrow(reps.overlap),"D"], geom = "density", fill = "density", alpha = 0.5) +
geom_vline(xintercept = reps.overlap[1,"D"], linetype = "longdash") +
xlim(0,1) + guides(fill = FALSE, alpha = FALSE) + xlab("D")
i.plot <- qplot(reps.overlap[2:nrow(reps.overlap),"I"], geom = "density", fill = "density", alpha = 0.5) +
geom_vline(xintercept = reps.overlap[1,"I"], linetype = "longdash") +
xlim(0,1) + guides(fill = FALSE, alpha = FALSE) + xlab("I")
cor.plot <- qplot(reps.overlap[2:nrow(reps.overlap),"rank.cor"], geom = "density", fill = "density", alpha = 0.5) +
geom_vline(xintercept = reps.overlap[1,"rank.cor"], linetype = "longdash") +
xlim(-1,1) + guides(fill = FALSE, alpha = FALSE) + xlab("Rank Correlation")
# mean(bg.dm[,1] > bg.dm[1,1])
output <- list(reps.overlap = reps.overlap,
p.values = p.values,
empirical.species.1.model = empirical.species.1.model,
empirical.species.2.model = empirical.species.1.model,
d.plot = d.plot,
i.plot = i.plot,
cor.plot = cor.plot)
class(output) <- "background.test"
return(output)
}
background.precheck <- function(species.1, species.2, env, type, f, nreps, test.type){
if(!"enmtools.species" %in% class(species.1)){
stop("Species.1 is not an enmtools.species object!")
}
if(!"enmtools.species" %in% class(species.2)){
stop("Species.2 is not an enmtools.species object!")
}
if(!grepl("Raster", class(env))){
stop("Environmental layers are not a RasterLayer or RasterStack object!")
}
if(type == "glm"){
if(is.null(f)){
stop("Type is set to GLM and no formula has been supplied!")
}
if(!"formula" %in% class(f)){
stop("Type is set to GLM and f is not a formula object!")
}
}
if(type == "mx"){
if(!grepl("raster", class(species.1$range), ignore.case = TRUE)){
stop("Maxent cannot use points for background, and species 1 does not have a range raster!")
}
if(!grepl("raster", class(species.2$range), ignore.case = TRUE)){
stop("Maxent cannot use points for background, and species 2 does not have a range raster!")
}
}
if(!type %in% c("glm", "mx", "bc", "dm")){
stop(paste("Model type", type, "not understood! Select either bc, dm, mx, or glm."))
}
check.species(species.1)
if(!any(c("data.frame") %in% class(species.1$presence.points))){
stop("Species 1 presence.points do not appear to be an object of class data.frame")
}
if(!any(c("data.frame") %in% class(species.1$background.points))){
stop("Species 1 background.points do not appear to be an object of class data.frame")
}
check.species(species.2)
#   if(bg.source == "points"){
#
#     if(!any(c("data.frame") %in% class(species.2$presence.points))){
#       stop("Species 2 presence.points do not appear to be an object of class data.frame")
#     }
#
#     if(!any(c("data.frame") %in% class(species.2$background.points))){
#       stop("Species 2 background.points do not appear to be an object of class data.frame")
#     }
#
#     if(any(!colnames(species.1$background.points) %in% colnames(species.2$background.points))){
#       stop("Column names for species background points do not match!")
#     }
#
#     if(any(!colnames(species.1$presence.points) %in% colnames(species.2$presence.points))){
#       stop("Column names for species presence points do not match!")
#     }
#   }
#   if(bg.source == "range"){
#     if(!grepl("raster", class(species.1$range), ignore.case = TRUE)){
#       stop("Species 1 does not have a range raster!")
#     }
#
#     if(!grepl("raster", class(species.2$range), ignore.case = TRUE)){
#       stop("Species 2 does not have a range raster!")
#     }
#   }
}
summary.background.test <- function(bg){
cat("\n\nbackground test p-values:\n")
print(bg$p.values)
cat("\n\nReplicates:\n")
print(kable(head(bg$reps.overlap)))
plot(bg)
}
print.background.test <- function(bg){
summary(bg)
}
plot.background.test <- function(bg){
grid.arrange(bg$d.plot, bg$i.plot, bg$cor.plot)
}
bg.mx.sym <- background.test(species.1 = ahli, species.2 = allogus, env = env, type = "mx",
f = presence ~ layer.1 + layer.2 + layer.3 + layer.4, nreps = 4, test.type = "symmetric" )
#' background.test Conduct a background test (also called a similarity test), as described in Warren et al. 2008.
#' This test can either be run as an asymmetric test (species.1 vs background of species.2) or as a symmetric test
#' (background of species.1 vs background of species.2).  For GLM, Bioclim, and Domain models the replicates will be
#' constructed from the background points supplied for each species.  For Maxent, the replicates will be constructed
#' from the range rasters stored in the enmtools.species objects.
#'
#' @param species.1 An emtools.species object from which presence points (asymmetric) or background (symmetric) will be sampled.
#' @param species.2 An enmtools.species object from which background will be sampled.
#' @param env A RasterLayer or RasterStack object containing environmental data
#' @param type The type of model to construct, currently accepts "glm", "mx", "bc", or "dm"
#' @param f A function to use for model fitting.  Only required for GLM models at the moment.
#' @param nreps Number of replicates to perform
#' @param ... Additional arguments to be passed to model fitting functions.
#'
#' @return results A list containing replicates, models for the empirical data, and summary statistics and plots.
#'
#' @keywords background, equivalency, enmtools, hypothesis testing
#'
#' @export background.test
#' @export background.precheck
#' @export print.background.test
#' @export summary.background.test
#' @export plot.background.test
#'
#' @examples
#' background.test(ahli, allogus, env, type = "glm", f = layer.1 + layer.2 + layer.3, nreps = 10, type = "asymmetric", ...)
#'
background.test <- function(species.1, species.2, env, type, f = NULL, nreps = 99, test.type = "asymmetric", ...){
#   if(type == "mx"){
#     bg.source = "range"
#   }
background.precheck(species.1, species.2, env, type, f, nreps, test.type)
if(type == "glm"){
cat("\nBuilding empirical models...\n")
empirical.species.1.model <- enmtools.glm(f, species.1, env, ...)
empirical.species.2.model <- enmtools.glm(f, species.2, env, ...)
empirical.overlap <- raster.overlap(empirical.species.1.model, empirical.species.2.model)
reps.overlap <- unlist(empirical.overlap)
cat("\nBuilding replicate models...\n")
for(i in 1:nreps){
cat(paste("\nReplicate", i, "...\n"))
rep.species.1 <- species.1
rep.species.2 <- species.2
if(test.type == "symmetric"){
#background sampling for species 1, only run when we're doing a symmetric test
combined.points <- rbind(rep.species.1$presence.points, rep.species.1$background.points)
sample.vector <- sample(nrow(combined.points))
combined.points <- combined.points[sample.vector,]
rep.species.1$presence.points <- combined.points[1:nrow(species.1$presence.points),]
rep.species.1$background.points <- combined.points[(nrow(species.1$presence.points) + 1):nrow(combined.points),]
}
# Background sampling for species 2, run regardless of the type of test
combined.points <- rbind(rep.species.2$presence.points, rep.species.2$background.points)
sample.vector <- sample(nrow(combined.points))
combined.points <- combined.points[sample.vector,]
rep.species.2$presence.points <- combined.points[1:nrow(species.2$presence.points),]
rep.species.2$background.points <- combined.points[(nrow(species.2$presence.points) + 1):nrow(combined.points),]
# Building the models for reps
rep.species.1.glm <- enmtools.glm(f, rep.species.1, env, ...)
rep.species.2.glm <- enmtools.glm(f, rep.species.2, env, ...)
# Appending to results
reps.overlap <- rbind(reps.overlap, unlist(raster.overlap(rep.species.1.glm, rep.species.2.glm)))
}
}
if(type == "mx"){
cat("\nBuilding empirical models...\n")
empirical.species.1.model <- enmtools.maxent(species.1, env, ...)
empirical.species.2.model <- enmtools.maxent(species.2, env, ...)
empirical.overlap <- raster.overlap(empirical.species.1.model, empirical.species.2.model)
reps.overlap <- unlist(empirical.overlap)
cat("\nBuilding replicate models...\n")
for(i in 1:nreps){
cat(paste("\nReplicate", i, "...\n"))
rep.species.1 <- species.1
rep.species.2 <- species.2
if(test.type == "symmetric"){
#background sampling for species 1, only run when we're doing a symmetric test
combined.points <- rbind(rep.species.1$presence.points, rep.species.1$background.points)
sample.vector <- sample(nrow(combined.points))
combined.points <- combined.points[sample.vector,]
rep.species.1$presence.points <- combined.points[1:nrow(species.1$presence.points),]
rep.species.1$background.points <- combined.points[(nrow(species.1$presence.points) + 1):nrow(combined.points),]
}
# Background sampling for species 2, run regardless of the type of test
combined.points <- rbind(rep.species.2$presence.points, rep.species.2$background.points)
sample.vector <- sample(nrow(combined.points))
combined.points <- combined.points[sample.vector,]
rep.species.2$presence.points <- combined.points[1:nrow(species.2$presence.points),]
rep.species.2$background.points <- combined.points[(nrow(species.2$presence.points) + 1):nrow(combined.points),]
rep.species.1.mx <- enmtools.maxent(rep.species.1, env, ...)
rep.species.2.mx <- enmtools.maxent(rep.species.2, env, ...)
# Appending to results
reps.overlap <- rbind(reps.overlap, unlist(raster.overlap(rep.species.1.mx, rep.species.2.mx)))
}
}
if(type == "bc"){
cat("\nBuilding empirical models...\n")
empirical.species.1.model <- enmtools.bc(species.1, env, ...)
empirical.species.2.model <- enmtools.bc(species.2, env, ...)
empirical.overlap <- raster.overlap(empirical.species.1.model, empirical.species.2.model)
reps.overlap <- unlist(empirical.overlap)
cat("\nBuilding replicate models...\n")
for(i in 1:nreps){
cat(paste("\nReplicate", i, "...\n"))
rep.species.1 <- species.1
rep.species.2 <- species.2
if(test.type == "symmetric"){
#background sampling for species 1, only run when we're doing a symmetric test
combined.points <- rbind(rep.species.1$presence.points, rep.species.1$background.points)
sample.vector <- sample(nrow(combined.points))
combined.points <- combined.points[sample.vector,]
rep.species.1$presence.points <- combined.points[1:nrow(species.1$presence.points),]
rep.species.1$background.points <- combined.points[(nrow(species.1$presence.points) + 1):nrow(combined.points),]
}
# Background sampling for species 2, run regardless of the type of test
combined.points <- rbind(rep.species.2$presence.points, rep.species.2$background.points)
sample.vector <- sample(nrow(combined.points))
combined.points <- combined.points[sample.vector,]
rep.species.2$presence.points <- combined.points[1:nrow(species.2$presence.points),]
rep.species.2$background.points <- combined.points[(nrow(species.2$presence.points) + 1):nrow(combined.points),]
rep.species.1.bc <- enmtools.bc(rep.species.1, env, ...)
rep.species.2.bc <- enmtools.bc(rep.species.2, env, ...)
# Appending to results
reps.overlap <- rbind(reps.overlap, unlist(raster.overlap(rep.species.1.bc, rep.species.2.bc)))
}
}
if(type == "dm"){
cat("\nBuilding empirical models...\n")
empirical.species.1.model <- enmtools.dm(species.1, env, ...)
empirical.species.2.model <- enmtools.dm(species.2, env, ...)
empirical.overlap <- raster.overlap(empirical.species.1.model, empirical.species.2.model)
reps.overlap <- unlist(empirical.overlap)
cat("\nBuilding replicate models...\n")
for(i in 1:nreps){
cat(paste("\nReplicate", i, "...\n"))
rep.species.1 <- species.1
rep.species.2 <- species.2
if(test.type == "symmetric"){
#background sampling for species 1, only run when we're doing a symmetric test
combined.points <- rbind(rep.species.1$presence.points, rep.species.1$background.points)
sample.vector <- sample(nrow(combined.points))
combined.points <- combined.points[sample.vector,]
rep.species.1$presence.points <- combined.points[1:nrow(species.1$presence.points),]
rep.species.1$background.points <- combined.points[(nrow(species.1$presence.points) + 1):nrow(combined.points),]
}
# Background sampling for species 2, run regardless of the type of test
combined.points <- rbind(rep.species.2$presence.points, rep.species.2$background.points)
sample.vector <- sample(nrow(combined.points))
combined.points <- combined.points[sample.vector,]
rep.species.2$presence.points <- combined.points[1:nrow(species.2$presence.points),]
rep.species.2$background.points <- combined.points[(nrow(species.2$presence.points) + 1):nrow(combined.points),]
rep.species.1.dm <- enmtools.dm(rep.species.1, env, ...)
rep.species.2.dm <- enmtools.dm(rep.species.2, env, ...)
# Appending to results
reps.overlap <- rbind(reps.overlap, unlist(raster.overlap(rep.species.1.dm, rep.species.2.dm)))
}
}
rownames(reps.overlap) <- c("empirical", paste("rep", 1:nreps))
p.values <- apply(reps.overlap, 2, function(x) 1 - mean(x > x[1]))
d.plot <- qplot(reps.overlap[2:nrow(reps.overlap),"D"], geom = "density", fill = "density", alpha = 0.5) +
geom_vline(xintercept = reps.overlap[1,"D"], linetype = "longdash") +
xlim(0,1) + guides(fill = FALSE, alpha = FALSE) + xlab("D")
i.plot <- qplot(reps.overlap[2:nrow(reps.overlap),"I"], geom = "density", fill = "density", alpha = 0.5) +
geom_vline(xintercept = reps.overlap[1,"I"], linetype = "longdash") +
xlim(0,1) + guides(fill = FALSE, alpha = FALSE) + xlab("I")
cor.plot <- qplot(reps.overlap[2:nrow(reps.overlap),"rank.cor"], geom = "density", fill = "density", alpha = 0.5) +
geom_vline(xintercept = reps.overlap[1,"rank.cor"], linetype = "longdash") +
xlim(-1,1) + guides(fill = FALSE, alpha = FALSE) + xlab("Rank Correlation")
# mean(bg.dm[,1] > bg.dm[1,1])
output <- list(reps.overlap = reps.overlap,
p.values = p.values,
empirical.species.1.model = empirical.species.1.model,
empirical.species.2.model = empirical.species.1.model,
d.plot = d.plot,
i.plot = i.plot,
cor.plot = cor.plot)
class(output) <- "background.test"
return(output)
}
background.precheck <- function(species.1, species.2, env, type, f, nreps, test.type){
if(!"enmtools.species" %in% class(species.1)){
stop("Species.1 is not an enmtools.species object!")
}
if(!"enmtools.species" %in% class(species.2)){
stop("Species.2 is not an enmtools.species object!")
}
if(!grepl("Raster", class(env))){
stop("Environmental layers are not a RasterLayer or RasterStack object!")
}
if(type == "glm"){
if(is.null(f)){
stop("Type is set to GLM and no formula has been supplied!")
}
if(!"formula" %in% class(f)){
stop("Type is set to GLM and f is not a formula object!")
}
}
#   if(type == "mx"){
#     if(!grepl("raster", class(species.1$range), ignore.case = TRUE)){
#       stop("Maxent cannot use points for background, and species 1 does not have a range raster!")
#     }
#
#     if(!grepl("raster", class(species.2$range), ignore.case = TRUE)){
#       stop("Maxent cannot use points for background, and species 2 does not have a range raster!")
#     }
#   }
if(!type %in% c("glm", "mx", "bc", "dm")){
stop(paste("Model type", type, "not understood! Select either bc, dm, mx, or glm."))
}
check.species(species.1)
if(!any(c("data.frame") %in% class(species.1$presence.points))){
stop("Species 1 presence.points do not appear to be an object of class data.frame")
}
if(!any(c("data.frame") %in% class(species.1$background.points))){
stop("Species 1 background.points do not appear to be an object of class data.frame")
}
check.species(species.2)
#   if(bg.source == "points"){
#
#     if(!any(c("data.frame") %in% class(species.2$presence.points))){
#       stop("Species 2 presence.points do not appear to be an object of class data.frame")
#     }
#
#     if(!any(c("data.frame") %in% class(species.2$background.points))){
#       stop("Species 2 background.points do not appear to be an object of class data.frame")
#     }
#
#     if(any(!colnames(species.1$background.points) %in% colnames(species.2$background.points))){
#       stop("Column names for species background points do not match!")
#     }
#
#     if(any(!colnames(species.1$presence.points) %in% colnames(species.2$presence.points))){
#       stop("Column names for species presence points do not match!")
#     }
#   }
#   if(bg.source == "range"){
#     if(!grepl("raster", class(species.1$range), ignore.case = TRUE)){
#       stop("Species 1 does not have a range raster!")
#     }
#
#     if(!grepl("raster", class(species.2$range), ignore.case = TRUE)){
#       stop("Species 2 does not have a range raster!")
#     }
#   }
}
summary.background.test <- function(bg){
cat("\n\nbackground test p-values:\n")
print(bg$p.values)
cat("\n\nReplicates:\n")
print(kable(head(bg$reps.overlap)))
plot(bg)
}
print.background.test <- function(bg){
summary(bg)
}
plot.background.test <- function(bg){
grid.arrange(bg$d.plot, bg$i.plot, bg$cor.plot)
}
bg.mx.sym <- background.test(species.1 = ahli, species.2 = allogus, env = env, type = "mx",
f = presence ~ layer.1 + layer.2 + layer.3 + layer.4, nreps = 19, test.type = "symmetric" )
=======
cat("\n")
}
plot.enmtools.clade <- function(this.clade){
# Figure out how many plots you need.  We'll do one for each species (up to 15)
# and one for the tree.
n.plot <- min(16, length(this.clade$species))
# We'll use this to keep track of how many plots we've made
plotted <- 0
# Figure out how many rows and columns we need, declare a new plot
n.rows <- ceiling(sqrt(n.plot))
n.cols <- ceiling(n.plot/n.rows)
plot.new()
par(mfrow = c(n.rows, n.cols))
for(i in 1:n.plot){
plot(this.clade$species[[i]])
}
}
print.enmtools.clade <- function(this.clade){
summary(this.clade)
}
ahli
allogus
two.anoles
two.anoles$species[[1]]
library(ENMTools)
two.anoles <- add.env(two.anoles)
two.anoles <- add.env(two.anoles, env)
ahli <- add.env(ahli)
ahli <- add.env(ahli, env)
allogus <- add.env(allogus, env)
source("~/GitHub/Topology-Levers/rewrite.nex/rewrite.nex.R")
filename <- "~/GitHub/Topology-Levers/rewrite.nex/alignment.nex"
file.exists(filename)
number_of_chains <- c(1, 2, 4, 8, 16, 32, 56)
chain_temperature <- c(0.0, 0.1, 0.2, 0.5, 1.0, 2.0, 5.0)
swaps_per_generation <- c(1, 2, 5, 10)
# Make a list of variables with varnames (must match var names in <>), use
# expand.grid to get combos
params <- expand.grid(list(number_of_chains = number_of_chains, chain_temperature = chain_temperature, swaps_per_generation = swaps_per_generation))
# Path to mb executable
# Call rewrite.nex, it makes the files
rewrite.nex(params, filename)
library(ENMTools)
test <- species ~ env1 + env2
test
attributes(test)
names(test)
terms(test)
test2 <- delete.response(test)
test2
terms(test2)
test
test2 <- delete.response(terms(test))
test2
test3 <- reformulate(test2, "fart")
test3 <- reformulate(test2, "term.labels")
test3 <- reformulate(test2, c("fart"))
help(reformulate)
test2$term.labels
reformulate(attr(test2, "term.labels"))
reformulate(attr(test2, "term.labels"), response = "fart")
#' Takes an emtools.species object with presence and background points, and builds a GLM
#'
#' @param formula Standard GLM formula
#' @param species An enmtools.species object
#'
#' @export enmtools.glm
enmtools.glm <- function(formula, species){
if(!class(formula) == "formula"){
stop("Argument \'formula\' must contain a formula object!")
}
if(!class(species) == enmtools.species){
stop("Argument \'species\' must contain an enmtools.species object!")
}
}
enmtools.glm(x ~ y, ahli)
enmtools.glm(formula(x ~ y), ahli)
#' Takes an emtools.species object with presence and background points, and builds a GLM
#'
#' @param formula Standard GLM formula
#' @param species An enmtools.species object
#'
#' @export enmtools.glm
enmtools.glm <- function(formula, species){
if(!class(formula) == "formula"){
stop("Argument \'formula\' must contain a formula object!")
}
if(!class(species) == "enmtools.species"){
stop("Argument \'species\' must contain an enmtools.species object!")
}
}
enmtools.glm(x ~ y, ahli)
class(ahli)
#' Takes an emtools.species object with presence and background points, and builds a GLM
#'
#' @param formula Standard GLM formula
#' @param species An enmtools.species object
#'
#' @export enmtools.glm
enmtools.glm <- function(formula, species){
if(!class(formula) == "formula"){
stop("Argument \'formula\' must contain a formula object!")
}
if(!"enmtools.species" %in% class(species)){
stop("Argument \'species\' must contain an enmtools.species object!")
}
}
enmtools.glm(x ~ y, ahli)
enmtools.glm("eat a dick", ahli)
#' Takes an emtools.species object with presence and background points, and builds a GLM
#'
#' @param formula Standard GLM formula
#' @param species An enmtools.species object
#'
#' @export enmtools.glm
enmtools.glm <- function(f, species){
if(!class(f) == "formula"){
stop("Argument \'formula\' must contain an R formula object!")
}
if(!"enmtools.species" %in% class(species)){
stop("Argument \'species\' must contain an enmtools.species object!")
}
# Going to recast this formula so that the response variable is named "presence"
# regardless of what was passed.
f <- reformulate(attr(delete.response(terms(f)), "term.labels"), response = "presence")
print(f)
}
enmtools.glm(x ~ y, ahli)
#' Takes an emtools.species object with presence and background points, and builds a GLM
#'
#' @param formula Standard GLM formula
#' @param species An enmtools.species object
#'
#' @export enmtools.glm
enmtools.glm <- function(f, species){
if(!class(f) == "formula"){
stop("Argument \'formula\' must contain an R formula object!")
}
if(!"enmtools.species" %in% class(species)){
stop("Argument \'species\' must contain an enmtools.species object!")
}
if(!any(c("data.frame") %in% class(species$presence.points))){
print("Species presence.points do not appear to be an object of class data.frame")
}
if(!any(c("data.frame") %in% class(species$background.points))){
print("Species background.points do not appear to be an object of class data.frame")
}
# Going to recast this formula so that the response variable is named "presence"
# regardless of what was passed.
f <- reformulate(attr(delete.response(terms(f)), "term.labels"), response = "presence")
analysis.df <- rbind(species$presence.points[,-c(1,2)], species$background.points[,-c(1,2)])
analysis.df$presence <- c(rep(1, length(species$presence.points)), rep(0, length(species$background.points)))
return(analysis.df)
}
test <- enmtools.glm(x ~ y, ahli)
#' Takes an emtools.species object with presence and background points, and builds a GLM
#'
#' @param formula Standard GLM formula
#' @param species An enmtools.species object
#'
#' @export enmtools.glm
enmtools.glm <- function(f, species){
if(!class(f) == "formula"){
stop("Argument \'formula\' must contain an R formula object!")
}
if(!"enmtools.species" %in% class(species)){
stop("Argument \'species\' must contain an enmtools.species object!")
}
if(!any(c("data.frame") %in% class(species$presence.points))){
print("Species presence.points do not appear to be an object of class data.frame")
}
if(!any(c("data.frame") %in% class(species$background.points))){
print("Species background.points do not appear to be an object of class data.frame")
}
# Going to recast this formula so that the response variable is named "presence"
# regardless of what was passed.
f <- reformulate(attr(delete.response(terms(f)), "term.labels"), response = "presence")
analysis.df <- rbind(species$presence.points[,-c(1,2)], species$background.points[,-c(1,2)])
analysis.df$presence <- c(rep(1, nrow(species$presence.points)), rep(0, nrow(species$background.points)))
return(analysis.df)
}
test <- enmtools.glm(x ~ y, ahli)
test
head(test)
#' Takes an emtools.species object with presence and background points, and builds a GLM
#'
#' @param formula Standard GLM formula
#' @param species An enmtools.species object
#'
#' @export enmtools.glm
enmtools.glm <- function(f, species){
if(!class(f) == "formula"){
stop("Argument \'formula\' must contain an R formula object!")
}
if(!"enmtools.species" %in% class(species)){
stop("Argument \'species\' must contain an enmtools.species object!")
}
if(!any(c("data.frame") %in% class(species$presence.points))){
print("Species presence.points do not appear to be an object of class data.frame")
}
if(!any(c("data.frame") %in% class(species$background.points))){
print("Species background.points do not appear to be an object of class data.frame")
}
# Going to recast this formula so that the response variable is named "presence"
# regardless of what was passed.
f <- reformulate(attr(delete.response(terms(f)), "term.labels"), response = "presence")
analysis.df <- rbind(species$presence.points[,-c(1,2)], species$background.points[,-c(1,2)])
analysis.df$presence <- c(rep(1, nrow(species$presence.points)), rep(0, nrow(species$background.points)))
this.glm <- glm(f, analysis.df, family="binomial")
output <- list(formula = f,
analysis.df = analysis.df,
model = this.glm)
return(output)
}
test <- enmtools.glm(species ~ layer.1 + layer.2, ahli)
test
test <- enmtools.glm(species ~ layer.1 + layer.2 + layer.3 + layer.4, ahli)
test
plot(test)
plot(test$model)
#' Takes an emtools.species object with presence and background points, and builds a GLM
#'
#' @param formula Standard GLM formula
#' @param species An enmtools.species object
#'
#' @export enmtools.glm
enmtools.glm <- function(f, species){
if(!class(f) == "formula"){
stop("Argument \'formula\' must contain an R formula object!")
}
if(!"enmtools.species" %in% class(species)){
stop("Argument \'species\' must contain an enmtools.species object!")
}
if(!any(c("data.frame") %in% class(species$presence.points))){
print("Species presence.points do not appear to be an object of class data.frame")
}
if(!any(c("data.frame") %in% class(species$background.points))){
print("Species background.points do not appear to be an object of class data.frame")
}
# Going to recast this formula so that the response variable is named "presence"
# regardless of what was passed.
f <- reformulate(attr(delete.response(terms(f)), "term.labels"), response = "presence")
analysis.df <- rbind(species$presence.points[,-c(1,2)], species$background.points[,-c(1,2)])
analysis.df$presence <- c(rep(1, nrow(species$presence.points)), rep(0, nrow(species$background.points)))
this.glm <- glm(f, analysis.df, family="binomial")
output <- list(formula = f,
analysis.df = analysis.df,
model = this.glm)
class(output) <- "enmtools.glm"
return(output)
}
test <- enmtools.glm(species ~ layer.1 + layer.2 + layer.3 + layer.4, ahli)
test
names(test)
#' Takes an emtools.species object with presence and background points, and builds a GLM
#'
#' @param formula Standard GLM formula
#' @param species An enmtools.species object
#'
#' @export enmtools.glm
enmtools.glm <- function(f, species){
if(!class(f) == "formula"){
stop("Argument \'formula\' must contain an R formula object!")
}
if(!"enmtools.species" %in% class(species)){
stop("Argument \'species\' must contain an enmtools.species object!")
}
if(!any(c("data.frame") %in% class(species$presence.points))){
print("Species presence.points do not appear to be an object of class data.frame")
}
if(!any(c("data.frame") %in% class(species$background.points))){
print("Species background.points do not appear to be an object of class data.frame")
}
# Going to recast this formula so that the response variable is named "presence"
# regardless of what was passed.
f <- reformulate(attr(delete.response(terms(f)), "term.labels"), response = "presence")
analysis.df <- rbind(species$presence.points[,-c(1,2)], species$background.points[,-c(1,2)])
analysis.df$presence <- c(rep(1, nrow(species$presence.points)), rep(0, nrow(species$background.points)))
this.glm <- glm(f, analysis.df, family="binomial")
output <- list(formula = f,
analysis.df = analysis.df,
model = this.glm)
class(output) <- "enmtools.glm"
return(output)
}
summary.enmtools.glm <- function(this.glm){
cat(paste("\n\nFormula:  ", this.glm$formula))
cat("\n\nData table (top ten lines): \n")
kable(head(this.glm$analysis.df, 10))
cat("\n\nModel:  ")
print(this.glm$model)
}
test
test
summary(test)
test$formula
#' Takes an emtools.species object with presence and background points, and builds a GLM
#'
#' @param formula Standard GLM formula
#' @param species An enmtools.species object
#'
#' @export enmtools.glm
enmtools.glm <- function(f, species){
if(!class(f) == "formula"){
stop("Argument \'formula\' must contain an R formula object!")
}
if(!"enmtools.species" %in% class(species)){
stop("Argument \'species\' must contain an enmtools.species object!")
}
if(!any(c("data.frame") %in% class(species$presence.points))){
print("Species presence.points do not appear to be an object of class data.frame")
}
if(!any(c("data.frame") %in% class(species$background.points))){
print("Species background.points do not appear to be an object of class data.frame")
}
# Going to recast this formula so that the response variable is named "presence"
# regardless of what was passed.
f <- reformulate(attr(delete.response(terms(f)), "term.labels"), response = "presence")
analysis.df <- rbind(species$presence.points[,-c(1,2)], species$background.points[,-c(1,2)])
analysis.df$presence <- c(rep(1, nrow(species$presence.points)), rep(0, nrow(species$background.points)))
this.glm <- glm(f, analysis.df, family="binomial")
output <- list(formula = f,
analysis.df = analysis.df,
model = this.glm)
class(output) <- "enmtools.glm"
return(output)
}
summary.enmtools.glm <- function(this.glm){
cat("\n\nFormula:  ")
print(this.glm$formula)
cat("\n\nData table (top ten lines): \n")
kable(head(this.glm$analysis.df, 10))
cat("\n\nModel:  ")
print(this.glm$model)
}
summary(test)
#' Takes an emtools.species object with presence and background points, and builds a GLM
#'
#' @param formula Standard GLM formula
#' @param species An enmtools.species object
#'
#' @export enmtools.glm
enmtools.glm <- function(f, species){
if(!class(f) == "formula"){
stop("Argument \'formula\' must contain an R formula object!")
}
if(!"enmtools.species" %in% class(species)){
stop("Argument \'species\' must contain an enmtools.species object!")
}
if(!any(c("data.frame") %in% class(species$presence.points))){
print("Species presence.points do not appear to be an object of class data.frame")
}
if(!any(c("data.frame") %in% class(species$background.points))){
print("Species background.points do not appear to be an object of class data.frame")
}
# Going to recast this formula so that the response variable is named "presence"
# regardless of what was passed.
f <- reformulate(attr(delete.response(terms(f)), "term.labels"), response = "presence")
analysis.df <- rbind(species$presence.points[,-c(1,2)], species$background.points[,-c(1,2)])
analysis.df$presence <- c(rep(1, nrow(species$presence.points)), rep(0, nrow(species$background.points)))
this.glm <- glm(f, analysis.df, family="binomial")
output <- list(formula = f,
analysis.df = analysis.df,
model = this.glm)
class(output) <- "enmtools.glm"
return(output)
}
summary.enmtools.glm <- function(this.glm){
cat("\n\nFormula:  ")
print(this.glm$formula)
cat("\n\nData table (top ten lines): \n")
print(kable(head(this.glm$analysis.df, 10)))
cat("\n\nModel:  ")
print(this.glm$model)
}
summary(test)
#' Takes an emtools.species object with presence and background points, and builds a GLM
#'
#' @param formula Standard GLM formula
#' @param species An enmtools.species object
#'
#' @export enmtools.glm
enmtools.glm <- function(f, species){
if(!class(f) == "formula"){
stop("Argument \'formula\' must contain an R formula object!")
}
if(!"enmtools.species" %in% class(species)){
stop("Argument \'species\' must contain an enmtools.species object!")
}
if(!any(c("data.frame") %in% class(species$presence.points))){
print("Species presence.points do not appear to be an object of class data.frame")
}
if(!any(c("data.frame") %in% class(species$background.points))){
print("Species background.points do not appear to be an object of class data.frame")
}
# Going to recast this formula so that the response variable is named "presence"
# regardless of what was passed.
f <- reformulate(attr(delete.response(terms(f)), "term.labels"), response = "presence")
analysis.df <- rbind(species$presence.points[,-c(1,2)], species$background.points[,-c(1,2)])
analysis.df$presence <- c(rep(1, nrow(species$presence.points)), rep(0, nrow(species$background.points)))
this.glm <- glm(f, analysis.df, family="binomial")
output <- list(formula = f,
analysis.df = analysis.df,
model = this.glm)
class(output) <- "enmtools.glm"
return(output)
}
summary.enmtools.glm <- function(this.glm){
cat("\n\nFormula:  ")
print(this.glm$formula)
cat("\n\nData table (top ten lines): \n")
print(kable(head(this.glm$analysis.df, 10)))
cat("\n\nModel:  ")
print(this.glm$model)
}
print.enmtools.glm <- function(this.glm){
summary(this.glm)
}
enmtools.glm(species ~ layer.1 * layer.3, allogus)
library(ENMTools)
install.packages("dismo")
install.packages("rJava")
install.packages("rgeos")
library(ENMTools)
setwd("~/GitHub/ENMTools/test")
library(ENMTools)
env.files <- list.files(path = "testdata/", pattern = "pc", full.names = TRUE)
env <- stack(env.files)
ahli <- enmtools.species()
check.species(ahli)
allogus <- enmtools.species(species.name = "allogus", presence.points = read.csv("testdata/allogus.csv")[,3:4])
check.species(allogus)
ahli <- enmtools.species(species.name = "ahli", presence.points = read.csv("testdata/ahli.csv")[,3:4])
check.species(ahli)
ahli$range <- background.raster.buffer(ahli$presence.points, 50000, mask = env)
allogus$range <- background.raster.buffer(allogus$presence.points, 50000, mask = env)
ahli$background.points <- background.points.buffer(points = ahli$presence.points,radius = 20000, n = 1000, mask = env[[1]])
allogus$background.points <- background.points.buffer(points = allogus$presence.points,radius = 20000, n = 1000, mask = env[[1]])
# Should fail because presence and background have different col names
check.species(ahli)
colnames(ahli$background.points) <- colnames(ahli$presence.points)
colnames(allogus$background.points) <- colnames(allogus$presence.points)
two.anoles <- enmtools.clade(list(ahli, allogus))
two.anoles
check.clade(two.anoles)
summary(ahli)
print(ahli)
plot(ahli)
summary(two.anoles)
plot(two.anoles)
ahli.glm <- enmtools.glm(pres ~ layer.1 + layer.2 + layer.3 + layer.4, ahli, env)
ahli.glm
ahli.twovar.glm <- enmtools.glm(pres ~ layer.1 + layer.4, ahli, env)
ahli.twovar.glm
ahli.bc <- enmtools.bc(ahli, env)
ahli.bc
ahli.mx <- enmtools.maxent(ahli, env)
ahli.mx <- enmtools.maxent(ahli, env)
ahli.mx
library(ENMTools)
setwd("~/GitHub/ENMTools/test")
library(ENMTools)
env.files <- list.files(path = "testdata/", pattern = "pc", full.names = TRUE)
env <- stack(env.files)
ahli <- enmtools.species()
check.species(ahli)
allogus <- enmtools.species(species.name = "allogus", presence.points = read.csv("testdata/allogus.csv")[,3:4])
check.species(allogus)
ahli <- enmtools.species(species.name = "ahli", presence.points = read.csv("testdata/ahli.csv")[,3:4])
check.species(ahli)
ahli$range <- background.raster.buffer(ahli$presence.points, 50000, mask = env)
allogus$range <- background.raster.buffer(allogus$presence.points, 50000, mask = env)
ahli$background.points <- background.points.buffer(points = ahli$presence.points,radius = 20000, n = 1000, mask = env[[1]])
allogus$background.points <- background.points.buffer(points = allogus$presence.points,radius = 20000, n = 1000, mask = env[[1]])
# Should fail because presence and background have different col names
check.species(ahli)
colnames(ahli$background.points) <- colnames(ahli$presence.points)
colnames(allogus$background.points) <- colnames(allogus$presence.points)
two.anoles <- enmtools.clade(list(ahli, allogus))
two.anoles
check.clade(two.anoles)
summary(ahli)
print(ahli)
plot(ahli)
summary(two.anoles)
plot(two.anoles)
ahli.glm <- enmtools.glm(pres ~ layer.1 + layer.2 + layer.3 + layer.4, ahli, env)
ahli.glm
ahli.twovar.glm <- enmtools.glm(pres ~ layer.1 + layer.4, ahli, env)
ahli.twovar.glm
# Presently leaving out GAM, as it is hard to see how I'm going to be able to
# use it in the same way as the other methods.
# ahli.gam <- enmtools.gam(presence ~, ahli, env)
ahli.bc <- enmtools.bc(ahli, env)
ahli.bc2 <- enmtools.bc(ahli, env[[c("layer.1", "layer.4")]])
ahli.mx <- enmtools.maxent(ahli, env)
ahli.mx
ahli.dm <- enmtools.dm(ahli, env)
ahli.dm
allogus.dm <- enmtools.dm(allogus, env)
allogus.dm
raster.cor(allogus.dm, ahli.dm)
raster.cor(ahli.mx, ahli.dm)
plot(raster.standardize(ahli.dm))
raster.breadth(allogus.dm)
raster.overlap(allogus.dm, allogus.dm$suitability)
raster.overlap(ahli.dm, allogus.dm)
raster.resid(ahli.mx, ahli.dm)
plot(raster.resid(ahli.mx, ahli.dm)$residuals)
bg.mx.sym <- background.test(species.1 = ahli, species.2 = allogus, env = env, type = "mx",
f = presence ~ layer.1 + layer.2 + layer.3 + layer.4, nreps = 4, test.type = "symmetric" )
maxent(env, ahli$presence.points, ahli$background.points)
>>>>>>> origin/starting-over
