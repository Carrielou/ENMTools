library(ENMTools)
makereport(allogus.glm, "allogus.test.html")
class(allogus.glm$response.plots)
grid.arrange(allogus.glm$response.plots, ncol = 3)
grid.arrange(unlist(allogus.glm$response.plots), ncol = 3)
allogus.glm$response.plots
library(ENMTools)
makereport(allogus.glm, "allogus.test.html")
plot(allogus.glm$training.evaluation)
plot(allogus.glm$training.evaluation, "ROC")
test <- plot(allogus.glm$training.evaluation, "ROC")
attributes(test)
test
test <- allogus.glm$training.evaluation
test
attributes(test)
names(test)
test@auc
test@confusion
head(test@confusion)
test@presence
plot(test, "ROC")
qplot(test@FPR, test@TPR)
qplot(test@FPR, test@TPR, geom = "line")
qplot(test@FPR, test@TPR, geom = "line") + theme_classic()
qplot(test@FPR, test@TPR, geom = "line", color = "red") + theme_classic()
qplot(test@FPR, test@TPR, geom = "line") + theme_classic()
library(ENMTools)
setwd("~/GitHub/ENMTools/test")
allogus <- enmtools.species(species.name = "allogus", presence.points = read.csv("testdata/allogus.csv")[,3:4])
check.species(allogus)
env.files <- list.files(path = "testdata/", pattern = "pc", full.names = TRUE)
env <- stack(env.files)
names(env) <- c("layer.1", "layer.2", "layer.3", "layer.4")
env <- setMinMax(env)
allogus.glm <- enmtools.glm(allogus, env, f = presence ~ layer.1 + layer.2, test.prop = 0.2)
plot(allogus.glm)
allogus.glm$test.evaluation
visualize.enm(allogus.glm, env, layers = c("layer.1", "layer.2"))
allogus.dm <- enmtools.dm(allogus, env[[c("layer.1", "layer.2")]], test.prop = 0.2)
plot(allogus.dm)
allogus.dm$test.evaluation
visualize.enm(allogus.dm, env, layers = c("layer.1", "layer.2"))
plot(allogus.glm)
allogus.glm
allogus.dm
plot(allogus.glm$env.training.evaluation)
plot(allogus.glm$env.training.evaluation, "ROC")
env.evaluate(allogus, allogus.glm, env)
test <- env.evaluate(allogus, allogus.glm, env)
test
names(test)
test@presence
test@absence
#' Calculates evaluation metrics (AUC, etc.) using latin hypercube sampling in environment space
#'
#' @param species An enmtools.species object
#' @param model An enmtools.model object or a model that can be projected using the predict() function of dismo
#' @param env A raster or raster stack of environmental data.
#' @param bg.source Determines whether minima and maxima of the environment space should be picked using the environment layers or the background points.
#' @param ... Arguments to be passed to othfer functions
#'
#' @export env.evaluate
env.evaluate <- function(species, model, env, bg.source = "background", ...){
species <- check.bg(species, env, ...)
if(!inherits(species, "enmtools.species")){
stop("Argument species must supply an enmtools.species object!")
}
presence <- species$presence.points[,1:2]
background <- species$background.points[,1:2]
if(inherits(model, "enmtools.model")){
model <- model$model
}
if(bg.source == "background"){
allpoints <- rbind(presence, background)
values <- extract(env, allpoints)
maxes <- apply(values, 2, function(x) max(x, na.rm = TRUE))
mins <- apply(values, 2, function(x) max(x, na.rm = TRUE))
}
if(bg.source == "env") {
maxes <- maxValue(env)
mins <- minValue(env)
}
this.lhs <- randomLHS(10000, length(names(env)))
bg.table <- t(t(this.lhs) * (maxes  - mins) + mins)
colnames(bg.table) <- names(env)
p.table <- extract(env, presence)
#
#   print(mins)
#   print(maxes)
#   print(head(bg.table))
#   print(head(p.table))
pred.p <- as.numeric(predict(model, data.frame(p.table), type = "response"))
pred.bg <- as.numeric(predict(model, data.frame(bg.table), type = "response"))
print(pred.bg)
env.evaluation <- evaluate(pred.p, pred.bg)
return(env.evaluation)
}
test <- env.evaluate(allogus, allogus.glm, env)
#' Calculates evaluation metrics (AUC, etc.) using latin hypercube sampling in environment space
#'
#' @param species An enmtools.species object
#' @param model An enmtools.model object or a model that can be projected using the predict() function of dismo
#' @param env A raster or raster stack of environmental data.
#' @param bg.source Determines whether minima and maxima of the environment space should be picked using the environment layers or the background points.
#' @param ... Arguments to be passed to othfer functions
#'
#' @export env.evaluate
env.evaluate <- function(species, model, env, bg.source = "background", ...){
species <- check.bg(species, env, ...)
if(!inherits(species, "enmtools.species")){
stop("Argument species must supply an enmtools.species object!")
}
presence <- species$presence.points[,1:2]
background <- species$background.points[,1:2]
if(inherits(model, "enmtools.model")){
model <- model$model
}
if(bg.source == "background"){
allpoints <- rbind(presence, background)
values <- extract(env, allpoints)
maxes <- apply(values, 2, function(x) max(x, na.rm = TRUE))
mins <- apply(values, 2, function(x) max(x, na.rm = TRUE))
}
if(bg.source == "env") {
maxes <- maxValue(env)
mins <- minValue(env)
}
this.lhs <- randomLHS(10000, length(names(env)))
bg.table <- t(t(this.lhs) * (maxes  - mins) + mins)
colnames(bg.table) <- names(env)
print(head(bg.table))
p.table <- extract(env, presence)
#
#   print(mins)
#   print(maxes)
#   print(head(bg.table))
#   print(head(p.table))
pred.p <- as.numeric(predict(model, data.frame(p.table), type = "response"))
pred.bg <- as.numeric(predict(model, data.frame(bg.table), type = "response"))
env.evaluation <- evaluate(pred.p, pred.bg)
return(env.evaluation)
}
test <- env.evaluate(allogus, allogus.glm, env)
randomLHS()
#' Calculates evaluation metrics (AUC, etc.) using latin hypercube sampling in environment space
#'
#' @param species An enmtools.species object
#' @param model An enmtools.model object or a model that can be projected using the predict() function of dismo
#' @param env A raster or raster stack of environmental data.
#' @param bg.source Determines whether minima and maxima of the environment space should be picked using the environment layers or the background points.
#' @param ... Arguments to be passed to othfer functions
#'
#' @export env.evaluate
env.evaluate <- function(species, model, env, bg.source = "background", ...){
species <- check.bg(species, env, ...)
if(!inherits(species, "enmtools.species")){
stop("Argument species must supply an enmtools.species object!")
}
presence <- species$presence.points[,1:2]
background <- species$background.points[,1:2]
if(inherits(model, "enmtools.model")){
model <- model$model
}
if(bg.source == "background"){
allpoints <- rbind(presence, background)
values <- extract(env, allpoints)
maxes <- apply(values, 2, function(x) max(x, na.rm = TRUE))
mins <- apply(values, 2, function(x) max(x, na.rm = TRUE))
}
if(bg.source == "env") {
maxes <- maxValue(env)
mins <- minValue(env)
}
this.lhs <- randomLHS(10000, length(names(env)))
print(this.lhs)
bg.table <- t(t(this.lhs) * (maxes  - mins) + mins)
colnames(bg.table) <- names(env)
p.table <- extract(env, presence)
#
#   print(mins)
#   print(maxes)
#   print(head(bg.table))
#   print(head(p.table))
pred.p <- as.numeric(predict(model, data.frame(p.table), type = "response"))
pred.bg <- as.numeric(predict(model, data.frame(bg.table), type = "response"))
env.evaluation <- evaluate(pred.p, pred.bg)
return(env.evaluation)
}
test <- env.evaluate(allogus, allogus.glm, env)
this.lhs <- randomLHS(10000, length(names(env)))
print(this.lhs)
maxes <- maxValue(env)
mins <- minValue(env)
maxes
mins
bg.table <- t(t(this.lhs) * (maxes  - mins) + mins)
head(bg.table)
colnames(bg.table) <- names(env)
head(bg.table)
#' Calculates evaluation metrics (AUC, etc.) using latin hypercube sampling in environment space
#'
#' @param species An enmtools.species object
#' @param model An enmtools.model object or a model that can be projected using the predict() function of dismo
#' @param env A raster or raster stack of environmental data.
#' @param bg.source Determines whether minima and maxima of the environment space should be picked using the environment layers or the background points.
#' @param ... Arguments to be passed to othfer functions
#'
#' @export env.evaluate
env.evaluate <- function(species, model, env, bg.source = "background", ...){
species <- check.bg(species, env, ...)
if(!inherits(species, "enmtools.species")){
stop("Argument species must supply an enmtools.species object!")
}
presence <- species$presence.points[,1:2]
background <- species$background.points[,1:2]
if(inherits(model, "enmtools.model")){
model <- model$model
}
if(bg.source == "background"){
allpoints <- rbind(presence, background)
values <- extract(env, allpoints)
maxes <- apply(values, 2, function(x) max(x, na.rm = TRUE))
mins <- apply(values, 2, function(x) max(x, na.rm = TRUE))
}
if(bg.source == "env") {
maxes <- maxValue(env)
mins <- minValue(env)
}
this.lhs <- randomLHS(10000, length(names(env)))
print(this.lhs)
bg.table <- t(t(this.lhs) * (maxes  - mins) + mins)
colnames(bg.table) <- names(env)
p.table <- extract(env, presence)
#
#   print(mins)
#   print(maxes)
#   print(head(bg.table))
#   print(head(p.table))
pred.p <- as.numeric(predict(model, data.frame(p.table), type = "response"))
pred.bg <- as.numeric(predict(model, data.frame(bg.table), type = "response"))
env.evaluation <- evaluate(pred.p, pred.bg)
return(env.evaluation)
}
test <- env.evaluate(allogus, allogus.glm, env)
test
#' Calculates evaluation metrics (AUC, etc.) using latin hypercube sampling in environment space
#'
#' @param species An enmtools.species object
#' @param model An enmtools.model object or a model that can be projected using the predict() function of dismo
#' @param env A raster or raster stack of environmental data.
#' @param bg.source Determines whether minima and maxima of the environment space should be picked using the environment layers or the background points.
#' @param ... Arguments to be passed to othfer functions
#'
#' @export env.evaluate
env.evaluate <- function(species, model, env, bg.source = "background", ...){
species <- check.bg(species, env, ...)
if(!inherits(species, "enmtools.species")){
stop("Argument species must supply an enmtools.species object!")
}
presence <- species$presence.points[,1:2]
background <- species$background.points[,1:2]
if(inherits(model, "enmtools.model")){
model <- model$model
}
if(bg.source == "background"){
allpoints <- rbind(presence, background)
values <- extract(env, allpoints)
maxes <- apply(values, 2, function(x) max(x, na.rm = TRUE))
mins <- apply(values, 2, function(x) max(x, na.rm = TRUE))
}
if(bg.source == "env") {
maxes <- maxValue(env)
mins <- minValue(env)
}
this.lhs <- randomLHS(10000, length(names(env)))
bg.table <- t(t(this.lhs) * (maxes  - mins) + mins)
colnames(bg.table) <- names(env)
print(head(bg.table))
p.table <- extract(env, presence)
#
#   print(mins)
#   print(maxes)
#   print(head(bg.table))
#   print(head(p.table))
pred.p <- as.numeric(predict(model, data.frame(p.table), type = "response"))
pred.bg <- as.numeric(predict(model, data.frame(bg.table), type = "response"))
env.evaluation <- evaluate(pred.p, pred.bg)
return(env.evaluation)
}
test <- env.evaluate(allogus, allogus.glm, env)
env
#' Calculates evaluation metrics (AUC, etc.) using latin hypercube sampling in environment space
#'
#' @param species An enmtools.species object
#' @param model An enmtools.model object or a model that can be projected using the predict() function of dismo
#' @param env A raster or raster stack of environmental data.
#' @param bg.source Determines whether minima and maxima of the environment space should be picked using the environment layers or the background points.
#' @param ... Arguments to be passed to othfer functions
#'
#' @export env.evaluate
env.evaluate <- function(species, model, env, bg.source = "background", ...){
species <- check.bg(species, env, ...)
if(!inherits(species, "enmtools.species")){
stop("Argument species must supply an enmtools.species object!")
}
presence <- species$presence.points[,1:2]
background <- species$background.points[,1:2]
if(inherits(model, "enmtools.model")){
model <- model$model
}
if(bg.source == "background"){
allpoints <- rbind(presence, background)
values <- extract(env, allpoints)
maxes <- apply(values, 2, function(x) max(x, na.rm = TRUE))
mins <- apply(values, 2, function(x) max(x, na.rm = TRUE))
}
if(bg.source == "env") {
maxes <- maxValue(env)
mins <- minValue(env)
}
this.lhs <- randomLHS(10000, length(names(env)))
bg.table <- t(t(this.lhs) * (maxes  - mins) + mins)
print(head(bg.table))
colnames(bg.table) <- names(env)
p.table <- extract(env, presence)
#
#   print(mins)
#   print(maxes)
#   print(head(bg.table))
#   print(head(p.table))
pred.p <- as.numeric(predict(model, data.frame(p.table), type = "response"))
pred.bg <- as.numeric(predict(model, data.frame(bg.table), type = "response"))
env.evaluation <- evaluate(pred.p, pred.bg)
return(env.evaluation)
}
test <- env.evaluate(allogus, allogus.glm, env)
#' Calculates evaluation metrics (AUC, etc.) using latin hypercube sampling in environment space
#'
#' @param species An enmtools.species object
#' @param model An enmtools.model object or a model that can be projected using the predict() function of dismo
#' @param env A raster or raster stack of environmental data.
#' @param bg.source Determines whether minima and maxima of the environment space should be picked using the environment layers or the background points.
#' @param ... Arguments to be passed to othfer functions
#'
#' @export env.evaluate
env.evaluate <- function(species, model, env, bg.source = "background", ...){
species <- check.bg(species, env, ...)
if(!inherits(species, "enmtools.species")){
stop("Argument species must supply an enmtools.species object!")
}
presence <- species$presence.points[,1:2]
background <- species$background.points[,1:2]
if(inherits(model, "enmtools.model")){
model <- model$model
}
if(bg.source == "background"){
allpoints <- rbind(presence, background)
values <- extract(env, allpoints)
maxes <- apply(values, 2, function(x) max(x, na.rm = TRUE))
mins <- apply(values, 2, function(x) max(x, na.rm = TRUE))
}
if(bg.source == "env") {
maxes <- maxValue(env)
mins <- minValue(env)
}
this.lhs <- randomLHS(10000, length(names(env)))
bg.table <- t(t(this.lhs) * (maxes  - mins) + mins)
colnames(bg.table) <- names(env)
p.table <- extract(env, presence)
#
#   print(mins)
#   print(maxes)
#   print(head(bg.table))
#   print(head(p.table))
pred.p <- as.numeric(predict(model, data.frame(p.table), type = "response"))
pred.bg <- as.numeric(predict(model, data.frame(bg.table), type = "response"))
env.evaluation <- evaluate(pred.p, pred.bg)
return(eval = env.evaluation,
lhs = this.lhs,
maxes = maxes,
mins = mins)
}
test <- env.evaluate(allogus, allogus.glm, env)
#' Calculates evaluation metrics (AUC, etc.) using latin hypercube sampling in environment space
#'
#' @param species An enmtools.species object
#' @param model An enmtools.model object or a model that can be projected using the predict() function of dismo
#' @param env A raster or raster stack of environmental data.
#' @param bg.source Determines whether minima and maxima of the environment space should be picked using the environment layers or the background points.
#' @param ... Arguments to be passed to othfer functions
#'
#' @export env.evaluate
env.evaluate <- function(species, model, env, bg.source = "background", ...){
species <- check.bg(species, env, ...)
if(!inherits(species, "enmtools.species")){
stop("Argument species must supply an enmtools.species object!")
}
presence <- species$presence.points[,1:2]
background <- species$background.points[,1:2]
if(inherits(model, "enmtools.model")){
model <- model$model
}
if(bg.source == "background"){
allpoints <- rbind(presence, background)
values <- extract(env, allpoints)
maxes <- apply(values, 2, function(x) max(x, na.rm = TRUE))
mins <- apply(values, 2, function(x) max(x, na.rm = TRUE))
}
if(bg.source == "env") {
maxes <- maxValue(env)
mins <- minValue(env)
}
this.lhs <- randomLHS(10000, length(names(env)))
bg.table <- t(t(this.lhs) * (maxes  - mins) + mins)
colnames(bg.table) <- names(env)
p.table <- extract(env, presence)
#
#   print(mins)
#   print(maxes)
#   print(head(bg.table))
#   print(head(p.table))
pred.p <- as.numeric(predict(model, data.frame(p.table), type = "response"))
pred.bg <- as.numeric(predict(model, data.frame(bg.table), type = "response"))
env.evaluation <- evaluate(pred.p, pred.bg)
return(list(eval = env.evaluation,
lhs = this.lhs,
maxes = maxes,
mins = mins))
}
test <- env.evaluate(allogus, allogus.glm, env)
t(t(test$lhs) * (maxes - mins) + mins)
library(ENMTools)
test <- env.evaluate(allogus, allogus.glm, env)
test
library(ENMTools)
test <- env.evaluate(allogus, allogus.glm, env)
library(ENMTools)
test
#' Calculates evaluation metrics (AUC, etc.) using latin hypercube sampling in environment space
#'
#' @param species An enmtools.species object
#' @param model An enmtools.model object or a model that can be projected using the predict() function of dismo
#' @param env A raster or raster stack of environmental data.
#' @param bg.source Determines whether minima and maxima of the environment space should be picked using the environment layers or the background points.
#' @param ... Arguments to be passed to othfer functions
#'
#' @export env.evaluate
env.evaluate <- function(species, model, env, bg.source = "background", ...){
species <- check.bg(species, env, ...)
if(!inherits(species, "enmtools.species")){
stop("Argument species must supply an enmtools.species object!")
}
presence <- species$presence.points[,1:2]
background <- species$background.points[,1:2]
if(inherits(model, "enmtools.model")){
model <- model$model
}
if(bg.source == "background"){
allpoints <- rbind(presence, background)
values <- extract(env, allpoints)
maxes <- apply(values, 2, function(x) max(x, na.rm = TRUE))
mins <- apply(values, 2, function(x) min(x, na.rm = TRUE))
}
if(bg.source == "env") {
maxes <- maxValue(env)
mins <- minValue(env)
}
this.lhs <- randomLHS(10000, length(names(env)))
bg.table <- t(t(this.lhs) * (maxes  - mins) + mins)
colnames(bg.table) <- names(env)
p.table <- extract(env, presence)
#
#   print(mins)
#   print(maxes)
#   print(head(bg.table))
#   print(head(p.table))
pred.p <- as.numeric(predict(model, data.frame(p.table), type = "response"))
pred.bg <- as.numeric(predict(model, data.frame(bg.table), type = "response"))
env.evaluation <- evaluate(pred.p, pred.bg)
return(env.evaluation)
}
test <- env.evaluate(allogus, allogus.glm, env)
test
test <- env.evaluate(allogus, allogus.dm, env)
test
library(ENMTools)
setwd("~/GitHub/ENMTools/test")
library(ENMTools)
# This code builds the readme.rmd file into a regular md file, which GitHub understands better
# knit(input="~/GitHub/ENMTools/Readme.Rmd", output = "~/GitHub/ENMTools/readme.md")
env.files <- list.files(path = "testdata/", pattern = "pc", full.names = TRUE)
env <- stack(env.files)
names(env) <- c("layer.1", "layer.2", "layer.3", "layer.4")
env <- setMinMax(env)
ahli <- enmtools.species()
check.species(ahli)
allogus <- enmtools.species(species.name = "allogus", presence.points = read.csv("testdata/allogus.csv")[,3:4])
check.species(allogus)
ahli <- enmtools.species(species.name = "ahli", presence.points = read.csv("testdata/ahli.csv")[,3:4])
check.species(ahli)
ahli$range <- background.raster.buffer(ahli$presence.points, 50000, mask = env)
allogus$range <- background.raster.buffer(allogus$presence.points, 50000, mask = env)
ahli$background.points <- background.points.buffer(points = ahli$presence.points,radius = 40000, n = 1000, mask = env[[1]])
allogus$background.points <- background.points.buffer(points = allogus$presence.points,radius = 40000, n = 1000, mask = env[[1]])
colnames(ahli$background.points) <- colnames(ahli$presence.points)
colnames(allogus$background.points) <- colnames(allogus$presence.points)
args <- c("betamultiplier=0.5", "product=FALSE", "hinge=FALSE", "threshold=FALSE")
args <- c("betamultiplier=0.5", "product=FALSE", "hinge=FALSE", "threshold=FALSE")
allogus.mx.args <- enmtools.maxent(allogus, env[[c("layer.1", "layer.4")]], test.prop = 0.2, args)
allogus.mx.args
plot(allogus.mx.args)
