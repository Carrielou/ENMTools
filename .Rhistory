if(!isTRUE(is.na(this.clade$tree))){
in.tree <- species.name %in% this.clade$tree$tip.label
}
presence <- lapply(this.clade$species, function(x) nrow(x$presence.points))
background <- unlist(lapply(this.clade$species, function(x) nrow(x$background.points)))
background[which(is.null(background))] <- 0
range <- unlist(lapply(this.clade$species, function(x) inherits(x$range, c("raster", "RasterLayer"))))
range[which(range == TRUE)] <- "present"
range[which(range == FALSE)] <- "absent"
this.clade$summary <- cbind(species.name, in.tree, presence, background, range)
return(this.clade)
}
check.clade(two.anoles)
two.anoles <- check.clade(two.anoles)
two.anoles$summary
kable(two.anoles$summary)
two.anoles <- check.clade(two.anoles)
two.anoles
#' Defining a class for enmtools.clade.  Each clade gets:
#' @param species A list of enmtools.species objects
#' @param tree A tree showing the relationships between the species
#'
#' @export enmtools.clade
#' @export summary.enmtools.clade
#' @export print.enmtools.clade
#' @export plot.enmtools.clade
enmtools.clade <- function(species = NA, tree = NA, root.species = NA){
# Checking classes of input args.  The isTRUE stuff is needed because R doesn't
# know how to do is.na on raster data, so it was barfing and error when a raster
# was passed in.
if(!isTRUE(is.na(species))){
# Checking to see if species is a list
if(!"list" %in% class(species)){
print("Argument species requires a list of enmtools.species objects")
}
# This if statement is asking whether any of the list elements don't have
# enmtools.species in their class definitions
if(any(unlist(lapply(species, function(x) !"enmtools.species" %in% class(x))))){
print("The following objects in the species list do not appear to be enmtools.species objects:")
print(names(which(unlist(lapply(species, function(x) !"enmtools.species" %in% class(x))))))
}
}
if(!isTRUE(is.na(tree))){
# Checking to see if species is a list
if(!"phylo" %in% class(tree)){
print("Argument tree requires a phylo object")
}
}
output <- list(species = species,
tree = tree)
class(output) <- c("list", "enmtools.clade")
return(output)
}
summary.enmtools.clade <- function(this.clade){
this.clade <- check.clade(this.clade)
cat(paste("\n\nAn enmtools.clade object with", length(this.clade$species), "species\n"))
cat("\nSpecies names: \n")
cat(paste("\t", lapply(this.clade$species, function(x) x$species.name)))
cat("\n\nTree: \n")
print(this.clade$tree)
cat("\n\nData Summary: \n")
print(this.clade$summary)
cat("\n")
}
plot.enmtools.clade <- function(this.clade){
# Figure out how many plots you need.  We'll do one for each species (up to 15)
# and one for the tree.
n.plot <- min(16, length(this.clade$species))
# We'll use this to keep track of how many plots we've made
plotted <- 0
# Figure out how many rows and columns we need, declare a new plot
n.rows <- ceiling(sqrt(n.plot))
n.cols <- ceiling(n.plot/n.rows)
plot.new()
par(mfrow = c(n.rows, n.cols))
for(i in 1:n.plot){
plot(this.clade$species[[i]])
}
par(mfrow = c(1,1))
}
print.enmtools.clade <- function(this.clade){
summary(this.clade)
}
two.anoles
ahli2 <- ahli
ahli2$range <- NA
three.anoles <- enmtools.clade(ahli, allogus, ahli2)
three.anoles <- enmtools.clade(list(ahli, allogus, ahli2))
three.anoles
summary(two.anoles)
plot(two.anoles)
ahli.glm <- enmtools.glm(ahli, env, pres ~ layer.1 + layer.2 + layer.3 + layer.4, test.prop = 0.2)
ahli.glm
ahli.glm$response.plots
ahli.gam <- enmtools.gam(ahli, env, test.prop = 0.2, k = 10)
ahli.gam
ahli.gam$response.plots
visualize.enm(ahli.gam, env, layers = c("layer.1", "layer.2"))
onevar.glm <- enmtools.glm(ahli, env, pres ~ layer.1, test.prop = 0.2)
onevar.glm
onevar.glm$response.plots
allogus.glm <- enmtools.glm(allogus, env, pres ~ layer.1 + layer.2 + layer.3 + layer.4)
allogus.glm
allogus.glm <- enmtools.glm(allogus, env, pres ~ layer.1 + layer.2 + layer.3 + layer.4, test.prop = 0.3)
allogus.glm
plot(allogus.glm)
plot(ahli.gam)
ahli.gam$suitability
env.plots <- visualize.enm(allogus.glm, env, layers = c("layer.1", "layer.2"))
env.plots
ahli.twovar.glm <- enmtools.glm(ahli, env, pres ~ layer.1 + layer.4)
ahli.twovar.glm
# Ought to work on methods for GAM and others that auto-parse functions like the GLM one does now
ahli.bc <- enmtools.bc(ahli, env, test.prop = 0.2)
ahli.bc
ahli.bc$response.plots
ahli.bc2 <- enmtools.bc(ahli, env[[c("layer.1", "layer.4")]])
ahli.mx <- enmtools.maxent(ahli, env, test.prop = 0.2)
ahli.mx
ahli.mx$response.plots
visualize.enm(ahli.mx, env, ("layer.3", "layer.4"))
visualize.enm(ahli.mx, env, c("layer.3", "layer.4"))
visualize.enm(ahli.mx, env, layers = c("layer.3", "layer.4"))
allogus.mx <- enmtools.maxent(allogus, env, test.prop = 0.2)
allogus.mx
visualize.enm(allogus.mx, env, layers = c("layer.3", "layer.4"))
#' visualize.overlap, Makes a contour map of suitability of habitat in environment space for two models
#'
#' @param model.1 An enmtools.model object
#' @param model.2 An enmtools.model object
#' @param env A set of environmental layers
#' @param nbins The number of bins per layer to use for drawing environment space
#' @param layers A vector of layer names to use for drawing environment space
#' @param plot.points Logical determining whether presence points should be plotted on suitability plot
#'
#' @return overlap.plot A two dimensional plot of an ENM
#'
#' @keywords niche plot sdm enm overlap
#'
#' @export visualize.overlap
#'
#' @examples
#' visualize.enm(1, .001, .001)
visualize.overlap <- function(model.1, model.2, env, nbins = 100, layers, plot.points = TRUE){
if(!inherits(model.1, "enmtools.model")){
stop("This function requires two enmtools.model objects!")
}
if(!inherits(model.2, "enmtools.model")){
stop("This function requires two enmtools.model objects!")
}
if(length(layers) != 2){
stop("Layers argument must be a character vector specifying two environmental layers to use for plotting!")
}
if(!all(layers %in% names(env))){
stop("Layer names provided do not match environmental rasters!")
}
# Grab points
if(inherits(model.1, c("enmtools.bc", "enmtools.dm"))){
points.1 <- model.1$analysis.df
} else {
points.1 <- model.1$analysis.df[model.1$analysis.df$presence == 1,1:2]
}
if(inherits(model.2, c("enmtools.bc", "enmtools.dm"))){
points.2 <- model.2$analysis.df
} else {
points.2 <- model.2$analysis.df[model.2$analysis.df$presence == 1,1:2]
}
layer1.min <- min(getValues(env[[layers[1]]]), na.rm=TRUE)
layer2.min <- min(getValues(env[[layers[2]]]), na.rm=TRUE)
layer1.max <- max(getValues(env[[layers[1]]]), na.rm=TRUE)
layer2.max <- max(getValues(env[[layers[2]]]), na.rm=TRUE)
# Build plot df
plot.df <- cbind(rep(seq(layer1.min, layer1.max, length = nbins), nbins),
rep(seq(layer2.min, layer2.max, length = nbins), each = nbins))
# Create a vector of names in the right order for plot.df
names <- layers
# Set value to mean for all non-target vars
for(i in names(env)){
if(!(i %in% layers)){
layer.values <- extract(env[[i]], rbind(points.1, points.2))
plot.df <- cbind(plot.df, rep(mean(layer.values, na.rm=TRUE), nrow(plot.df)))
names <- c(names, i)
}
}
pointdata.1 <- as.data.frame(extract(env[[layers]], points.1))
pointdata.2 <- as.data.frame(extract(env[[layers]], points.2))
colnames(plot.df) <- names
plot.df <- data.frame(plot.df)
pred.1 <- predict(model.1$model, plot.df, type = "response")
pred.2 <- predict(model.2$model, plot.df, type = "response")
plot.df <- cbind(plot.df[,1:2], pred.1, pred.2)
#This is where I'm going to need to look up how to overlap two contours!
overlap.plot <- ggplot(data = plot.df, aes_string(y = names[2], x = names[1])) +
geom_contour(aes(z = pred.1)) + geom_contour(aes(z = pred.2)) +
scale_fill_viridis(option = "B", guide = guide_colourbar(title = "Suitability")) +
theme_classic() +
ggtitle(label = "Predicted suitability in environment space")
# if(plot.points == TRUE){
#   suit.plot <- suit.plot  + geom_point(data = pointdata, aes_string(y = names[2], x = names[1]),
#                                        pch = 21, fill = "white", color = "black", size = 3)
# }
output <- overlap.plot
return(output)
}
visualize.overlap(ahli.mx, allogus.mx, env, layers = c("layer.3", "layer.4"))
test <- visualize.overlap(ahli.mx, allogus.mx, env, layers = c("layer.3", "layer.4"))
test
test + scale_fill_viridis(option = "B", guide = guide_colourbar(title = "Suitability"))
test + scale_color_viridis(option = "B", guide = guide_colourbar(title = "Suitability"))
library(viridis)
test + scale_color_viridis(option = "B", guide = guide_colourbar(title = "Suitability"))
allogus.mx$response.plots
allogus.dm <- enmtools.dm(allogus, env, test.prop = 0.2)
allogus.dm
ahli.bc
#' Takes an emtools.species object with presence and background points, and builds a Bioclim model
#'
#' @param species An enmtools.species object
#' @param env A raster or raster stack of environmental data.
#' @param test.prop Proportion of data to withhold for model evaluation
#' @param ... Arguments to be passed to bioclim()
#'
#' @export enmtools.bc
#' @export print.enmtools.bc
#' @export summary.enmtools.bc
#' @export plot.enmtools.bc
enmtools.bc <- function(species, env = NA, test.prop = 0, ...){
notes <- NULL
species <- check.bg(species, env, ...)
bc.precheck(species, env)
test.data <- NA
test.evaluation <- NA
env.test.evaluation <- NA
if(test.prop > 0 & test.prop < 1){
test.inds <- sample(1:nrow(species$presence.points), ceiling(nrow(species$presence.points) * test.prop))
test.data <- species$presence.points[test.inds,]
species$presence.points <- species$presence.points[-test.inds,]
}
# This is a very weird hack that has to be done because dismo's evaluate and bioclim function
# fail if the stack only has one layer.
if(length(names(env)) == 1){
oldname <- names(env)
env <- stack(env, env)
env[[2]][!is.na(env[[2]])] <- 0
names(env) <- c(oldname, "dummyvar")
notes <- c(notes, "Only one predictor was provided, so a dummy variable was created in order to be compatible with dismo's prediction function.")
}
this.bc <- bioclim(env, species$presence.points[,1:2])
suitability <- suitability <- predict(env, this.bc, type = "response")
# This is a very weird hack that has to be done because dismo's evaluate function
# fails if the stack only has one layer.
if(length(names(env)) == 1){
oldname <- names(env)
env <- stack(env, env)
names(env) <- c(oldname, "dummyvar")
}
model.evaluation <- evaluate(species$presence.points[,1:2], species$background.points[,1:2],
this.bc, env)
env.model.evaluation <- env.evaluate(species, this.bc, env)
if(test.prop > 0 & test.prop < 1){
test.evaluation <- evaluate(test.data, species$background.points[,1:2],
this.bc, env)
temp.sp <- species
temp.sp$presence.points <- test.data
env.test.evaluation <- env.evaluate(temp.sp, this.bc, env)
}
output <- list(analysis.df = species$presence.points[,1:2],
test.data = test.data,
test.prop = test.prop,
model = this.bc,
training.evaluation = model.evaluation,
test.evaluation = test.evaluation,
env.training.evaluation = env.model.evaluation,
env.test.evaluation = env.test.evaluation,
suitability = suitability,
notes = notes)
class(output) <- c("enmtools.bc", "enmtools.model")
# Doing response plots for each variable.  Doing this bit after creating
# the output object because plot.response expects an enmtools.model object
response.plots <- list()
for(i in names(env)){
response.plots[[i]] <- plot.response(output, env, i)
}
output[["response.plots"]] <- response.plots
return(output)
}
# Summary for objects of class enmtools.bc
summary.enmtools.bc <- function(this.bc){
cat("\n\nData table (top ten lines): ")
print(kable(head(this.bc$analysis.df, 10)))
cat("\n\nModel:  ")
print(this.bc$model)
cat("\n\nModel fit (training data):  ")
print(this.bc$training.evaluation)
cat("\n\nEnvironment space model fit (training data):  ")
print(this.bc$env.training.evaluation)
cat("\n\nProportion of data wittheld for model fitting:  ")
cat(this.bc$test.prop)
cat("\n\nModel fit (test data):  ")
print(this.bc$test.evaluation)
cat("\n\nEnvironment space model fit (test data):  ")
print(this.bc$env.test.evaluation)
cat("\n\nNotes:  \n")
print(this.bc$notes)
cat("\n\nSuitability:  \n")
print(this.bc$suitability)
plot(this.bc)
}
#Print method for objects of class enmtools.bc
print.enmtools.bc <- function(this.bc){
print(summary(this.bc))
}
# Plot method for objects of class enmtools.bc
plot.enmtools.bc <- function(this.bc){
suit.points <- data.frame(rasterToPoints(this.bc$suitability))
colnames(suit.points) <- c("Longitude", "Latitude", "Suitability")
suit.plot <- ggplot(data = suit.points, aes(y = Latitude, x = Longitude)) +
geom_raster(aes(fill = Suitability)) +
scale_fill_viridis(option = "B", guide = guide_colourbar(title = "Suitability")) +
coord_fixed() + theme_classic() +
geom_point(data = this.bc$analysis.df, aes(x = Longitude, y = Latitude),
pch = 21, fill = "white", color = "black", size = 2)
if(!(all(is.na(this.bc$test.data)))){
suit.plot <- suit.plot + geom_point(data = this.bc$test.data, aes(x = Longitude, y = Latitude),
pch = 21, fill = "green", color = "black", size = 2)
}
return(suit.plot)
}
# Checking data for analysis using enmtools.bc
bc.precheck <- function(species, env, f){
### Check to make sure the data we need is there
if(!inherits(species, "enmtools.species")){
stop("Argument \'species\' must contain an enmtools.species object!")
}
check.species(species)
if(!inherits(species$presence.points, "data.frame")){
stop("Species presence.points do not appear to be an object of class data.frame")
}
if(!inherits(env, c("raster", "RasterLayer", "RasterStack", "RasterBrick"))){
stop("No environmental rasters were supplied!")
}
if(ncol(species$presence.points) != 2){
stop("Species presence points do not contain longitude and latitude data!")
}
}
#' Takes an emtools.species object with presence and background points, and builds a Bioclim model
#'
#' @param species An enmtools.species object
#' @param env A raster or raster stack of environmental data.
#' @param test.prop Proportion of data to withhold for model evaluation
#' @param ... Arguments to be passed to bioclim()
#'
#' @export enmtools.bc
#' @export print.enmtools.bc
#' @export summary.enmtools.bc
#' @export plot.enmtools.bc
enmtools.bc <- function(species, env = NA, test.prop = 0, ...){
notes <- NULL
species <- check.bg(species, env, ...)
bc.precheck(species, env)
test.data <- NA
test.evaluation <- NA
env.test.evaluation <- NA
if(test.prop > 0 & test.prop < 1){
test.inds <- sample(1:nrow(species$presence.points), ceiling(nrow(species$presence.points) * test.prop))
test.data <- species$presence.points[test.inds,]
species$presence.points <- species$presence.points[-test.inds,]
}
# This is a very weird hack that has to be done because dismo's evaluate and bioclim function
# fail if the stack only has one layer.
if(length(names(env)) == 1){
oldname <- names(env)
env <- stack(env, env)
env[[2]][!is.na(env[[2]])] <- 0
names(env) <- c(oldname, "dummyvar")
notes <- c(notes, "Only one predictor was provided, so a dummy variable was created in order to be compatible with dismo's prediction function.")
}
this.bc <- bioclim(env, species$presence.points[,1:2])
suitability <- suitability <- predict(env, this.bc, type = "response")
# This is a very weird hack that has to be done because dismo's evaluate function
# fails if the stack only has one layer.
if(length(names(env)) == 1){
oldname <- names(env)
env <- stack(env, env)
names(env) <- c(oldname, "dummyvar")
}
model.evaluation <- evaluate(species$presence.points[,1:2], species$background.points[,1:2],
this.bc, env)
env.model.evaluation <- env.evaluate(species, this.bc, env)
if(test.prop > 0 & test.prop < 1){
test.evaluation <- evaluate(test.data, species$background.points[,1:2],
this.bc, env)
temp.sp <- species
temp.sp$presence.points <- test.data
env.test.evaluation <- env.evaluate(temp.sp, this.bc, env)
}
output <- list(analysis.df = species$presence.points[,1:2],
test.data = test.data,
test.prop = test.prop,
model = this.bc,
training.evaluation = model.evaluation,
test.evaluation = test.evaluation,
env.training.evaluation = env.model.evaluation,
env.test.evaluation = env.test.evaluation,
suitability = suitability,
notes = notes)
class(output) <- c("enmtools.bc", "enmtools.model")
# Doing response plots for each variable.  Doing this bit after creating
# the output object because plot.response expects an enmtools.model object
response.plots <- list()
for(i in names(env)){
response.plots[[i]] <- plot.response(output, env, i)
}
output[["response.plots"]] <- response.plots
return(output)
}
# Summary for objects of class enmtools.bc
summary.enmtools.bc <- function(this.bc){
cat("\n\nData table (top ten lines): ")
print(kable(head(this.bc$analysis.df, 10)))
cat("\n\nModel:  ")
print(this.bc$model)
cat("\n\nModel fit (training data):  ")
print(this.bc$training.evaluation)
cat("\n\nEnvironment space model fit (training data):  ")
print(this.bc$env.training.evaluation)
cat("\n\nProportion of data wittheld for model fitting:  ")
cat(this.bc$test.prop)
cat("\n\nModel fit (test data):  ")
print(this.bc$test.evaluation)
cat("\n\nEnvironment space model fit (test data):  ")
print(this.bc$env.test.evaluation)
cat("\n\nNotes:  \n")
print(this.bc$notes)
cat("\n\nSuitability:  \n")
print(this.bc$suitability)
plot(this.bc)
}
#Print method for objects of class enmtools.bc
print.enmtools.bc <- function(this.bc){
print(summary(this.bc))
}
# Plot method for objects of class enmtools.bc
plot.enmtools.bc <- function(this.bc){
suit.points <- data.frame(rasterToPoints(this.bc$suitability))
colnames(suit.points) <- c("Longitude", "Latitude", "Suitability")
suit.plot <- ggplot(data = suit.points, aes(y = Latitude, x = Longitude)) +
geom_raster(aes(fill = Suitability)) +
scale_fill_viridis(option = "B", guide = guide_colourbar(title = "Suitability")) +
coord_fixed() + theme_classic() +
geom_point(data = this.bc$analysis.df, aes(x = Longitude, y = Latitude),
pch = 21, fill = "white", color = "black", size = 2)
if(!(all(is.na(this.bc$test.data)))){
suit.plot <- suit.plot + geom_point(data = this.bc$test.data, aes(x = Longitude, y = Latitude),
pch = 21, fill = "green", color = "black", size = 2)
}
return(suit.plot)
}
# Checking data for analysis using enmtools.bc
bc.precheck <- function(species, env, f){
### Check to make sure the data we need is there
if(!inherits(species, "enmtools.species")){
stop("Argument \'species\' must contain an enmtools.species object!")
}
check.species(species)
if(!inherits(species$presence.points, "data.frame")){
stop("Species presence.points do not appear to be an object of class data.frame")
}
if(!inherits(env, c("raster", "RasterLayer", "RasterStack", "RasterBrick"))){
stop("No environmental rasters were supplied!")
}
if(ncol(species$presence.points) != 2){
stop("Species presence points do not contain longitude and latitude data!")
}
}
ahli.bc
library(ENMTools)
rm(list = ls(all = TRUE))
setwd("~/GitHub/ENMTools/test")
library(ENMTools)
env.files <- list.files(path = "testdata/", pattern = "pc", full.names = TRUE)
env <- stack(env.files)
names(env) <- c("layer.1", "layer.2", "layer.3", "layer.4")
env <- setMinMax(env)
ahli <- enmtools.species()
check.species(ahli)
allogus <- enmtools.species(species.name = "allogus", presence.points = read.csv("testdata/allogus.csv")[,3:4])
check.species(allogus)
ahli <- enmtools.species(species.name = "ahli", presence.points = read.csv("testdata/ahli.csv")[,3:4])
check.species(ahli)
ahli$range <- background.raster.buffer(ahli$presence.points, 50000, mask = env)
allogus$range <- background.raster.buffer(allogus$presence.points, 50000, mask = env)
ahli$background.points <- background.points.buffer(points = ahli$presence.points,radius = 40000, n = 1000, mask = env[[1]])
allogus$background.points <- background.points.buffer(points = allogus$presence.points,radius = 40000, n = 1000, mask = env[[1]])
# Should fail because presence and background have different col names
check.species(ahli)
colnames(ahli$background.points) <- colnames(ahli$presence.points)
colnames(allogus$background.points) <- colnames(allogus$presence.points)
two.anoles <- enmtools.clade(list(ahli, allogus))
two.anoles <- check.clade(two.anoles)
two.anoles
summary(ahli)
print(ahli)
plot(ahli)
summary(two.anoles)
plot(two.anoles)
ahli.glm <- enmtools.glm(ahli, env, pres ~ layer.1 + layer.2 + layer.3 + layer.4, test.prop = 0.2)
ahli.glm
ahli.glm
summary.enmtools.glm
rm(list = ls(all = TRUE))
summary.enmtools.glm
