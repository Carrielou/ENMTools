# know how to do is.na on raster data, so it was barfing and error when a raster
# was passed in.
if(!isTRUE(is.na(species))){
# Checking to see if species is a list
if(!"list" %in% class(species)){
print("Argument species requires a list of enmtools.species objects")
}
# This if statement is asking whether any of the list elements don't have
# enmtools.species in their class definitions
if(any(unlist(lapply(species, function(x) !"enmtools.species" %in% class(x))))){
print("The following objects in the species list do not appear to be enmtools.species objects:")
print(names(which(unlist(lapply(species, function(x) !"enmtools.species" %in% class(x))))))
}
}
if(!isTRUE(is.na(tree))){
# Checking to see if species is a list
if(!"phylo" %in% class(tree)){
print("Argument tree requires a phylo object")
}
}
output <- list(species = species,
tree = tree)
class(output) <- c("list", "enmtools.clade")
return(output)
}
summary.enmtools.clade <- function(this.clade){
cat(paste("\n\nAn enmtools.clade object with", length(this.clade$species), "species\n"))
cat("\nSpecies names: \n")
cat(paste("\t", lapply(this.clade$species, function(x) x$species.name)))
cat("\n\nTree: \n")
print(this.clade$tree)
cat("\n")
}
plot.enmtools.clade <- function(this.clade){
# Figure out how many plots you need.  We'll do one for each species (up to 15)
# and one for the tree.
n.plot <- min(16, length(this.clade$species))
# We'll use this to keep track of how many plots we've made
plotted <- 0
# Figure out how many rows and columns we need, declare a new plot
n.rows <- ceiling(sqrt(n.plot))
n.cols <- ceiling(n.plot/n.rows)
plot.new()
par(mfrow = c(n.rows, n.cols))
for(i in 1:n.plot){
plot(this.clade$species[[i]])
}
}
print.enmtools.clade <- function(this.clade){
}
plot(two.anoles)
#' Defining a class for enmtools.clade.  Each clade gets:
#' @param species A list of enmtools.species objects
#' @param tree A tree showing the relationships between the species
#'
#' @export enmtools.clade
#' @export summary.enmtools.clade
#' @export print.enmtools.clade
#' @export plot.enmtools.clade
enmtools.clade <- function(species = NA, tree = NA, root.species = NA){
# Checking classes of input args.  The isTRUE stuff is needed because R doesn't
# know how to do is.na on raster data, so it was barfing and error when a raster
# was passed in.
if(!isTRUE(is.na(species))){
# Checking to see if species is a list
if(!"list" %in% class(species)){
print("Argument species requires a list of enmtools.species objects")
}
# This if statement is asking whether any of the list elements don't have
# enmtools.species in their class definitions
if(any(unlist(lapply(species, function(x) !"enmtools.species" %in% class(x))))){
print("The following objects in the species list do not appear to be enmtools.species objects:")
print(names(which(unlist(lapply(species, function(x) !"enmtools.species" %in% class(x))))))
}
}
if(!isTRUE(is.na(tree))){
# Checking to see if species is a list
if(!"phylo" %in% class(tree)){
print("Argument tree requires a phylo object")
}
}
output <- list(species = species,
tree = tree)
class(output) <- c("list", "enmtools.clade")
return(output)
}
summary.enmtools.clade <- function(this.clade){
cat(paste("\n\nAn enmtools.clade object with", length(this.clade$species), "species\n"))
cat("\nSpecies names: \n")
cat(paste("\t", lapply(this.clade$species, function(x) x$species.name)))
cat("\n\nTree: \n")
print(this.clade$tree)
cat("\n")
}
plot.enmtools.clade <- function(this.clade){
# Figure out how many plots you need.  We'll do one for each species (up to 15)
# and one for the tree.
n.plot <- min(16, length(this.clade$species))
# We'll use this to keep track of how many plots we've made
plotted <- 0
# Figure out how many rows and columns we need, declare a new plot
n.rows <- ceiling(sqrt(n.plot))
n.cols <- ceiling(n.plot/n.rows)
plot.new()
par(mfrow = c(n.rows, n.cols))
for(i in 1:n.plot){
plot(this.clade$species[[i]])
}
}
print.enmtools.clade <- function(this.clade){
summary(this.clade)
}
ahli
allogus
two.anoles
two.anoles$species[[1]]
library(ENMTools)
two.anoles <- add.env(two.anoles)
two.anoles <- add.env(two.anoles, env)
ahli <- add.env(ahli)
ahli <- add.env(ahli, env)
allogus <- add.env(allogus, env)
source("~/GitHub/Topology-Levers/rewrite.nex/rewrite.nex.R")
filename <- "~/GitHub/Topology-Levers/rewrite.nex/alignment.nex"
file.exists(filename)
number_of_chains <- c(1, 2, 4, 8, 16, 32, 56)
chain_temperature <- c(0.0, 0.1, 0.2, 0.5, 1.0, 2.0, 5.0)
swaps_per_generation <- c(1, 2, 5, 10)
# Make a list of variables with varnames (must match var names in <>), use
# expand.grid to get combos
params <- expand.grid(list(number_of_chains = number_of_chains, chain_temperature = chain_temperature, swaps_per_generation = swaps_per_generation))
# Path to mb executable
# Call rewrite.nex, it makes the files
rewrite.nex(params, filename)
library(ENMTools)
test <- species ~ env1 + env2
test
attributes(test)
names(test)
terms(test)
test2 <- delete.response(test)
test2
terms(test2)
test
test2 <- delete.response(terms(test))
test2
test3 <- reformulate(test2, "fart")
test3 <- reformulate(test2, "term.labels")
test3 <- reformulate(test2, c("fart"))
help(reformulate)
test2$term.labels
reformulate(attr(test2, "term.labels"))
reformulate(attr(test2, "term.labels"), response = "fart")
#' Takes an emtools.species object with presence and background points, and builds a GLM
#'
#' @param formula Standard GLM formula
#' @param species An enmtools.species object
#'
#' @export enmtools.glm
enmtools.glm <- function(formula, species){
if(!class(formula) == "formula"){
stop("Argument \'formula\' must contain a formula object!")
}
if(!class(species) == enmtools.species){
stop("Argument \'species\' must contain an enmtools.species object!")
}
}
enmtools.glm(x ~ y, ahli)
enmtools.glm(formula(x ~ y), ahli)
#' Takes an emtools.species object with presence and background points, and builds a GLM
#'
#' @param formula Standard GLM formula
#' @param species An enmtools.species object
#'
#' @export enmtools.glm
enmtools.glm <- function(formula, species){
if(!class(formula) == "formula"){
stop("Argument \'formula\' must contain a formula object!")
}
if(!class(species) == "enmtools.species"){
stop("Argument \'species\' must contain an enmtools.species object!")
}
}
enmtools.glm(x ~ y, ahli)
class(ahli)
#' Takes an emtools.species object with presence and background points, and builds a GLM
#'
#' @param formula Standard GLM formula
#' @param species An enmtools.species object
#'
#' @export enmtools.glm
enmtools.glm <- function(formula, species){
if(!class(formula) == "formula"){
stop("Argument \'formula\' must contain a formula object!")
}
if(!"enmtools.species" %in% class(species)){
stop("Argument \'species\' must contain an enmtools.species object!")
}
}
enmtools.glm(x ~ y, ahli)
enmtools.glm("eat a dick", ahli)
#' Takes an emtools.species object with presence and background points, and builds a GLM
#'
#' @param formula Standard GLM formula
#' @param species An enmtools.species object
#'
#' @export enmtools.glm
enmtools.glm <- function(f, species){
if(!class(f) == "formula"){
stop("Argument \'formula\' must contain an R formula object!")
}
if(!"enmtools.species" %in% class(species)){
stop("Argument \'species\' must contain an enmtools.species object!")
}
# Going to recast this formula so that the response variable is named "presence"
# regardless of what was passed.
f <- reformulate(attr(delete.response(terms(f)), "term.labels"), response = "presence")
print(f)
}
enmtools.glm(x ~ y, ahli)
#' Takes an emtools.species object with presence and background points, and builds a GLM
#'
#' @param formula Standard GLM formula
#' @param species An enmtools.species object
#'
#' @export enmtools.glm
enmtools.glm <- function(f, species){
if(!class(f) == "formula"){
stop("Argument \'formula\' must contain an R formula object!")
}
if(!"enmtools.species" %in% class(species)){
stop("Argument \'species\' must contain an enmtools.species object!")
}
if(!any(c("data.frame") %in% class(species$presence.points))){
print("Species presence.points do not appear to be an object of class data.frame")
}
if(!any(c("data.frame") %in% class(species$background.points))){
print("Species background.points do not appear to be an object of class data.frame")
}
# Going to recast this formula so that the response variable is named "presence"
# regardless of what was passed.
f <- reformulate(attr(delete.response(terms(f)), "term.labels"), response = "presence")
analysis.df <- rbind(species$presence.points[,-c(1,2)], species$background.points[,-c(1,2)])
analysis.df$presence <- c(rep(1, length(species$presence.points)), rep(0, length(species$background.points)))
return(analysis.df)
}
test <- enmtools.glm(x ~ y, ahli)
#' Takes an emtools.species object with presence and background points, and builds a GLM
#'
#' @param formula Standard GLM formula
#' @param species An enmtools.species object
#'
#' @export enmtools.glm
enmtools.glm <- function(f, species){
if(!class(f) == "formula"){
stop("Argument \'formula\' must contain an R formula object!")
}
if(!"enmtools.species" %in% class(species)){
stop("Argument \'species\' must contain an enmtools.species object!")
}
if(!any(c("data.frame") %in% class(species$presence.points))){
print("Species presence.points do not appear to be an object of class data.frame")
}
if(!any(c("data.frame") %in% class(species$background.points))){
print("Species background.points do not appear to be an object of class data.frame")
}
# Going to recast this formula so that the response variable is named "presence"
# regardless of what was passed.
f <- reformulate(attr(delete.response(terms(f)), "term.labels"), response = "presence")
analysis.df <- rbind(species$presence.points[,-c(1,2)], species$background.points[,-c(1,2)])
analysis.df$presence <- c(rep(1, nrow(species$presence.points)), rep(0, nrow(species$background.points)))
return(analysis.df)
}
test <- enmtools.glm(x ~ y, ahli)
test
head(test)
#' Takes an emtools.species object with presence and background points, and builds a GLM
#'
#' @param formula Standard GLM formula
#' @param species An enmtools.species object
#'
#' @export enmtools.glm
enmtools.glm <- function(f, species){
if(!class(f) == "formula"){
stop("Argument \'formula\' must contain an R formula object!")
}
if(!"enmtools.species" %in% class(species)){
stop("Argument \'species\' must contain an enmtools.species object!")
}
if(!any(c("data.frame") %in% class(species$presence.points))){
print("Species presence.points do not appear to be an object of class data.frame")
}
if(!any(c("data.frame") %in% class(species$background.points))){
print("Species background.points do not appear to be an object of class data.frame")
}
# Going to recast this formula so that the response variable is named "presence"
# regardless of what was passed.
f <- reformulate(attr(delete.response(terms(f)), "term.labels"), response = "presence")
analysis.df <- rbind(species$presence.points[,-c(1,2)], species$background.points[,-c(1,2)])
analysis.df$presence <- c(rep(1, nrow(species$presence.points)), rep(0, nrow(species$background.points)))
this.glm <- glm(f, analysis.df, family="binomial")
output <- list(formula = f,
analysis.df = analysis.df,
model = this.glm)
return(output)
}
test <- enmtools.glm(species ~ layer.1 + layer.2, ahli)
test
test <- enmtools.glm(species ~ layer.1 + layer.2 + layer.3 + layer.4, ahli)
test
plot(test)
plot(test$model)
#' Takes an emtools.species object with presence and background points, and builds a GLM
#'
#' @param formula Standard GLM formula
#' @param species An enmtools.species object
#'
#' @export enmtools.glm
enmtools.glm <- function(f, species){
if(!class(f) == "formula"){
stop("Argument \'formula\' must contain an R formula object!")
}
if(!"enmtools.species" %in% class(species)){
stop("Argument \'species\' must contain an enmtools.species object!")
}
if(!any(c("data.frame") %in% class(species$presence.points))){
print("Species presence.points do not appear to be an object of class data.frame")
}
if(!any(c("data.frame") %in% class(species$background.points))){
print("Species background.points do not appear to be an object of class data.frame")
}
# Going to recast this formula so that the response variable is named "presence"
# regardless of what was passed.
f <- reformulate(attr(delete.response(terms(f)), "term.labels"), response = "presence")
analysis.df <- rbind(species$presence.points[,-c(1,2)], species$background.points[,-c(1,2)])
analysis.df$presence <- c(rep(1, nrow(species$presence.points)), rep(0, nrow(species$background.points)))
this.glm <- glm(f, analysis.df, family="binomial")
output <- list(formula = f,
analysis.df = analysis.df,
model = this.glm)
class(output) <- "enmtools.glm"
return(output)
}
test <- enmtools.glm(species ~ layer.1 + layer.2 + layer.3 + layer.4, ahli)
test
names(test)
#' Takes an emtools.species object with presence and background points, and builds a GLM
#'
#' @param formula Standard GLM formula
#' @param species An enmtools.species object
#'
#' @export enmtools.glm
enmtools.glm <- function(f, species){
if(!class(f) == "formula"){
stop("Argument \'formula\' must contain an R formula object!")
}
if(!"enmtools.species" %in% class(species)){
stop("Argument \'species\' must contain an enmtools.species object!")
}
if(!any(c("data.frame") %in% class(species$presence.points))){
print("Species presence.points do not appear to be an object of class data.frame")
}
if(!any(c("data.frame") %in% class(species$background.points))){
print("Species background.points do not appear to be an object of class data.frame")
}
# Going to recast this formula so that the response variable is named "presence"
# regardless of what was passed.
f <- reformulate(attr(delete.response(terms(f)), "term.labels"), response = "presence")
analysis.df <- rbind(species$presence.points[,-c(1,2)], species$background.points[,-c(1,2)])
analysis.df$presence <- c(rep(1, nrow(species$presence.points)), rep(0, nrow(species$background.points)))
this.glm <- glm(f, analysis.df, family="binomial")
output <- list(formula = f,
analysis.df = analysis.df,
model = this.glm)
class(output) <- "enmtools.glm"
return(output)
}
summary.enmtools.glm <- function(this.glm){
cat(paste("\n\nFormula:  ", this.glm$formula))
cat("\n\nData table (top ten lines): \n")
kable(head(this.glm$analysis.df, 10))
cat("\n\nModel:  ")
print(this.glm$model)
}
test
test
summary(test)
test$formula
#' Takes an emtools.species object with presence and background points, and builds a GLM
#'
#' @param formula Standard GLM formula
#' @param species An enmtools.species object
#'
#' @export enmtools.glm
enmtools.glm <- function(f, species){
if(!class(f) == "formula"){
stop("Argument \'formula\' must contain an R formula object!")
}
if(!"enmtools.species" %in% class(species)){
stop("Argument \'species\' must contain an enmtools.species object!")
}
if(!any(c("data.frame") %in% class(species$presence.points))){
print("Species presence.points do not appear to be an object of class data.frame")
}
if(!any(c("data.frame") %in% class(species$background.points))){
print("Species background.points do not appear to be an object of class data.frame")
}
# Going to recast this formula so that the response variable is named "presence"
# regardless of what was passed.
f <- reformulate(attr(delete.response(terms(f)), "term.labels"), response = "presence")
analysis.df <- rbind(species$presence.points[,-c(1,2)], species$background.points[,-c(1,2)])
analysis.df$presence <- c(rep(1, nrow(species$presence.points)), rep(0, nrow(species$background.points)))
this.glm <- glm(f, analysis.df, family="binomial")
output <- list(formula = f,
analysis.df = analysis.df,
model = this.glm)
class(output) <- "enmtools.glm"
return(output)
}
summary.enmtools.glm <- function(this.glm){
cat("\n\nFormula:  ")
print(this.glm$formula)
cat("\n\nData table (top ten lines): \n")
kable(head(this.glm$analysis.df, 10))
cat("\n\nModel:  ")
print(this.glm$model)
}
summary(test)
#' Takes an emtools.species object with presence and background points, and builds a GLM
#'
#' @param formula Standard GLM formula
#' @param species An enmtools.species object
#'
#' @export enmtools.glm
enmtools.glm <- function(f, species){
if(!class(f) == "formula"){
stop("Argument \'formula\' must contain an R formula object!")
}
if(!"enmtools.species" %in% class(species)){
stop("Argument \'species\' must contain an enmtools.species object!")
}
if(!any(c("data.frame") %in% class(species$presence.points))){
print("Species presence.points do not appear to be an object of class data.frame")
}
if(!any(c("data.frame") %in% class(species$background.points))){
print("Species background.points do not appear to be an object of class data.frame")
}
# Going to recast this formula so that the response variable is named "presence"
# regardless of what was passed.
f <- reformulate(attr(delete.response(terms(f)), "term.labels"), response = "presence")
analysis.df <- rbind(species$presence.points[,-c(1,2)], species$background.points[,-c(1,2)])
analysis.df$presence <- c(rep(1, nrow(species$presence.points)), rep(0, nrow(species$background.points)))
this.glm <- glm(f, analysis.df, family="binomial")
output <- list(formula = f,
analysis.df = analysis.df,
model = this.glm)
class(output) <- "enmtools.glm"
return(output)
}
summary.enmtools.glm <- function(this.glm){
cat("\n\nFormula:  ")
print(this.glm$formula)
cat("\n\nData table (top ten lines): \n")
print(kable(head(this.glm$analysis.df, 10)))
cat("\n\nModel:  ")
print(this.glm$model)
}
summary(test)
#' Takes an emtools.species object with presence and background points, and builds a GLM
#'
#' @param formula Standard GLM formula
#' @param species An enmtools.species object
#'
#' @export enmtools.glm
enmtools.glm <- function(f, species){
if(!class(f) == "formula"){
stop("Argument \'formula\' must contain an R formula object!")
}
if(!"enmtools.species" %in% class(species)){
stop("Argument \'species\' must contain an enmtools.species object!")
}
if(!any(c("data.frame") %in% class(species$presence.points))){
print("Species presence.points do not appear to be an object of class data.frame")
}
if(!any(c("data.frame") %in% class(species$background.points))){
print("Species background.points do not appear to be an object of class data.frame")
}
# Going to recast this formula so that the response variable is named "presence"
# regardless of what was passed.
f <- reformulate(attr(delete.response(terms(f)), "term.labels"), response = "presence")
analysis.df <- rbind(species$presence.points[,-c(1,2)], species$background.points[,-c(1,2)])
analysis.df$presence <- c(rep(1, nrow(species$presence.points)), rep(0, nrow(species$background.points)))
this.glm <- glm(f, analysis.df, family="binomial")
output <- list(formula = f,
analysis.df = analysis.df,
model = this.glm)
class(output) <- "enmtools.glm"
return(output)
}
summary.enmtools.glm <- function(this.glm){
cat("\n\nFormula:  ")
print(this.glm$formula)
cat("\n\nData table (top ten lines): \n")
print(kable(head(this.glm$analysis.df, 10)))
cat("\n\nModel:  ")
print(this.glm$model)
}
print.enmtools.glm <- function(this.glm){
summary(this.glm)
}
enmtools.glm(species ~ layer.1 * layer.3, allogus)
library(ENMTools)
