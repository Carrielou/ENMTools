if(!any("data.frame" %in% class(x$background.points))){
stop("Argument background.points requires an object of class data.frame")
}
}
if(!isTRUE(is.na(x$species.name))){
if(!any("character" %in% class(x$species.name))){
stop("Argument species.name requires an object of class character")
}
}
if(!is.null(insist)){
missing <- insist[insist %in% names(which(is.na(x))) ]
if(length(missing) != 0){
stop(paste("Species", x$species.name, "is missing required information:", missing))
}
}
return(x)
}
check.species(ahli, insist = c("species.name", "presence.points"))
check.species(ahli, insist = c("species.name"))
apply(two.anoles$species, check.species)
apply(two.anoles$species, functions(x) check.species(x))
apply(two.anoles$species, function(x) check.species(x))
lapply(two.anoles$species, function(x) check.species(x))
lapply(two.anoles$species, function(x) check.species(x, insist = "background.points", "species.name"))
lapply(two.anoles$species, function(x) check.species(x, insist = c("background.points", "species.name")))
check.clade(two.anoles, insist = c("tree", "species"))
#' Defining a class for enmtools.clade.  Each clade gets:
#' @param species A list of enmtools.species objects
#' @param tree A tree showing the relationships between the species
#'
#' @export check.clade
check.clade <- function(x, insist = NULL){
# Checking classes of input args.  The isTRUE stuff is needed because R doesn't
# know how to do is.na on raster data, so it was barfing and error when a raster
# was passed in.
if(!isTRUE(is.na(x$species))){
# Checking to see if species is a list
if(!"list" %in% class(x$species)){
stop("Argument species requires a list of enmtools.species objects")
}
# This if statement is asking whether any of the list elements don't have
# enmtools.species in their class definitions
if(any(unlist(lapply(x$species, function(y) !"enmtools.species" %in% class(y))))){
stop("The following objects in the species list do not appear to be enmtools.species objects:")
stop(names(which(unlist(lapply(x$species, function(y) !"enmtools.species" %in% class(y))))))
}
lapply(x$species, function(y) check.species(y, insist))
}
if(!isTRUE(is.na(x$tree))){
# Checking to see if species is a list
if(!"phylo" %in% class(x$tree)){
stop("Argument tree requires a phylo object")
}
}
if(!is.null(insist)){
missing <- insist[insist %in% names(which(is.na(x))) ]
if(length(missing) != 0){
stop(paste("Species", x$species.name, "is missing required information:", missing))
}
}
return(x)
}
check.clade(two.anoles, insist = c("tree", "species"))
#' Defining a class for enmtools.clade.  Each clade gets:
#' @param species A list of enmtools.species objects
#' @param tree A tree showing the relationships between the species
#'
#' @export check.clade
check.clade <- function(x, insist = NULL){
# Checking classes of input args.  The isTRUE stuff is needed because R doesn't
# know how to do is.na on raster data, so it was barfing and error when a raster
# was passed in.
if(!isTRUE(is.na(x$species))){
# Checking to see if species is a list
if(!"list" %in% class(x$species)){
stop("Argument species requires a list of enmtools.species objects")
}
# This if statement is asking whether any of the list elements don't have
# enmtools.species in their class definitions
if(any(unlist(lapply(x$species, function(y) !"enmtools.species" %in% class(y))))){
stop("The following objects in the species list do not appear to be enmtools.species objects:")
stop(names(which(unlist(lapply(x$species, function(y) !"enmtools.species" %in% class(y))))))
}
lapply(x$species, function(y) check.species(y, insist))
}
if(!isTRUE(is.na(x$tree))){
# Checking to see if species is a list
if(!"phylo" %in% class(x$tree)){
stop("Argument tree requires a phylo object")
}
}
if(!is.null(insist)){
missing <- insist[insist %in% names(which(is.na(x))) ]
if(length(missing) != 0){
stop(paste("Clade is missing required information:", missing))
}
}
return(x)
}
check.clade(two.anoles, insist = c("tree", "species"))
data(ahli)
ahli
ahli
ahli <- enmtools.species(species.name = "ahli", presence.points <- ahli)
data(ahli)
ahli <- enmtools.species(species.name = "ahli", presence.points = ahli)
if(!any(c("data.frame") %in% class(presence.points))){
#' Defining a class for enmtools.species.
#'
#' Each species gets:
#' @param range A raster or SpatialPolygon with the actual range they occur in
#' @param presence.points A data frame with sampled localities
#' @param background.points A data frame with absence/pseudoabsence/background localities
#' @param species.name A character vector with the species name
#' @param models A list of models that are made for the species, which will
#'    be stuffed in there as we go along
#'
#' @export enmtools.species
enmtools.species <- function(range = NA, presence.points = NA, background.points = NA,
species.name = NA, models=NA){
# Checking classes of input args.  The isTRUE stuff is needed because R doesn't
# know how to do is.na on raster data, so it was barfing and error when a raster
# was passed in.
if(!isTRUE(is.na(range))){
if(!any(c("raster", "SpatialPolygons") %in% class(range))){
print("Argument range requires an object of class raster or SpatialPolygons")
}
}
if(!isTRUE(is.na(presence.points))){
if(!any(c("data.frame") %in% class(presence.points))){
print("Argument presence.points requires an object of class data.frame")
}
}
if(!isTRUE(is.na(background.points))){
if(!any("data.frame" %in% class(background.points))){
print("Argument background.points requires an object of class data.frame")
}
}
if(!isTRUE(is.na(species.name))){
if(!any("character" %in% class(species.name))){
print("Argument species.name requires an object of class character")
}
}
output <- list(
range = range,
presence.points = presence.points,
background.points = background.points,
models = models,
species.name = species.name)
class(output) <- c("list", "enmtools.species")
return(output)
}
#' Defining a class for enmtools.species.
#'
#' Each species gets:
#' @param range A raster or SpatialPolygon with the actual range they occur in
#' @param presence.points A data frame with sampled localities
#' @param background.points A data frame with absence/pseudoabsence/background localities
#' @param species.name A character vector with the species name
#' @param models A list of models that are made for the species, which will
#'    be stuffed in there as we go along
#'
#' @export enmtools.species
enmtools.species <- function(range = NA, presence.points = NA, background.points = NA,
species.name = NA, models=NA){
# Checking classes of input args.  The isTRUE stuff is needed because R doesn't
# know how to do is.na on raster data, so it was barfing and error when a raster
# was passed in.
if(!isTRUE(is.na(range))){
if(!any(c("raster", "SpatialPolygons") %in% class(range))){
print("Argument range requires an object of class raster or SpatialPolygons")
}
}
if(!isTRUE(is.na(presence.points))){
if(!any(c("data.frame") %in% class(presence.points))){
print("Argument presence.points requires an object of class data.frame")
}
}
if(!isTRUE(is.na(background.points))){
if(!any("data.frame" %in% class(background.points))){
print("Argument background.points requires an object of class data.frame")
}
}
if(!isTRUE(is.na(species.name))){
if(!any("character" %in% class(species.name))){
print("Argument species.name requires an object of class character")
}
}
output <- list(
range = range,
presence.points = presence.points,
background.points = background.points,
models = models,
species.name = species.name)
class(output) <- c("list", "enmtools.species")
return(output)
}
data(ahli)
ahli <- enmtools.species(species.name = "ahli", presence.points = ahli)
ahli
check.species(ahli, insist = c("species.name", "presence.points"))
#' Checking compliance for an object of class enmtools.species.
#'
#' Checks for existence and proper class of:
#' @param range A raster or SpatialPolygon with the actual range they occur in
#' @param presence.points A data frame with sampled localities
#' @param background.points A data frame with absence/pseudoabsence/background localities
#' @param species.name A character vector with the species name
#' @param models A list of models that are made for the species, which will be stuffed in there as we go along
#' @param inist A vector containing the names of variables that will be required for a species
#' to pass the check.  This is used by internal enmtools functions to make sure the necessary data is present
#' before processing anything.
#'
#' @export check.species
check.species <- function(x, insist = NULL){
# Checking classes of input args.  The isTRUE stuff is needed because R doesn't
# know how to do is.na on raster data, so it was barfing and error when a raster
# was passed in.
if(!isTRUE(is.na(x$range))){
if(!any(c("raster", "SpatialPolygons") %in% class(x$range))){
stop("Argument range requires an object of class raster or SpatialPolygons")
}
}
if(!isTRUE(is.na(x$presence.points))){
if(!any(c("data.frame") %in% class(x$presence.points))){
stop("Argument presence.points requires an object of class data.frame")
}
}
if(!isTRUE(is.na(x$background.points))){
if(!any("data.frame" %in% class(x$background.points))){
stop("Argument background.points requires an object of class data.frame")
}
}
if(!isTRUE(is.na(x$species.name))){
if(!any("character" %in% class(x$species.name))){
stop("Argument species.name requires an object of class character")
}
}
if(!is.null(insist)){
missing <- insist[insist %in% names(which(is.na(x))) ]
if(length(missing) != 0){
stop(paste("Species", x$species.name, "is missing required information:", missing))
}
}
return(x)
}
check.species(ahli, insist = c("species.name", "presence.points"))
data(ahli)
ahli
write.csv(ahli, file = "ahli.csv")
getwd()
data(allogus_east)
write.csv(allogus_east, file = "allogus.csv")
ahli <- enmtools.species(species.name = "ahli", presence.points = read.csv("ahli.csv"))
allogus <- enmtools.species(species.name = "allogus", presence.points = read.csv("allogus.csv"))
check.species(allogus)
ahli <- enmtools.species(species.name = "ahli", presence.points = read.csv("ahli.csv"))
allogus$species.name <- "allogus"
check.species(ahli)
two.anoles <- enmtools.clade(list(ahli, allogus))
two.anoles
check.clade(two.anoles)
check.clade(two.anoles, insist = c("tree", "species"))
lapply(two.anoles$species, function(x) check.species(x, insist = c("background.points", "species.name")))
library(ENMTools)
setwd("~/GitHub/ENMTools/test")
library(ENMTools)
ahli <- enmtools.species()
check.species(ahli)
allogus <- enmtools.species(species.name = "allogus", presence.points = read.csv("allogus.csv"))
check.species(allogus)
ahli <- enmtools.species(species.name = "ahli", presence.points = read.csv("ahli.csv"))
check.species(ahli)
two.anoles <- enmtools.clade(list(ahli, allogus))
two.anoles
check.clade(two.anoles)
# NOTE TO SELF: analysis functions will need to check clade and species separately.  This is
# so we can require different things at the clade and species level, and not pass "tree" etc.
# to the species insist vector. Something like this:
check.clade(two.anoles)
lapply(two.anoles$species, function(x) check.species(x))
data(ahli.raster)
plot(ahli.raster)
data(env)
plot(env)
setwd("~/GitHub/ENMTools/test")
library(ENMTools)
ahli <- enmtools.species()
check.species(ahli)
allogus <- enmtools.species(species.name = "allogus", presence.points = read.csv("testdata/allogus.csv"))
check.species(allogus)
ahli <- enmtools.species(species.name = "ahli", presence.points = read.csv("testdata/ahli.csv"))
check.species(ahli)
test <- raster("testdata/ahli.asc")
plot(test)
library(alphahull)
test <- help(raster)
help(raster)
help("alpha")
help("ahull")
test <- ahull(ahli$presence.points)
test <- ahull(ahli$presence.points, alpha = 20)
test <- ahull(ahli$presence.points, alpha = 10)
test <- ahull(ahli$presence.points, alpha = 5)
test <- ahull(ahli$presence.points[,2:3], alpha = 5)
head(ahli$presence.points)
ahli <- enmtools.species()
check.species(ahli)
allogus <- enmtools.species(species.name = "allogus", presence.points = read.csv("testdata/allogus.csv")[,3:4])
check.species(allogus)
ahli <- enmtools.species(species.name = "ahli", presence.points = read.csv("testdata/ahli.csv")[,3:4])
check.species(ahli)
test <- ahull(ahli$presence.points, alpha = 5)
test
plot(test)
names(test)
library(ENMTools)
library(ENMTools)
library(ENMTools)
library(ENMTools)
library(ENMTools)
library(ENMTools)
ahli$presence.points
test <- background.shape.buffer(ahli$presence.points, radius = 10000)
plot(test)
points(ahli$presence.points, add = TRUE)
plot(test)
plot(ahli$presence.points, add = TRUE)
test2 <- background.shape.buffer(allogus$presence.points, 10000)
plot(test2)
warnings()
warnings()
plot(test2)
test2 <- background.shape.buffer(allogus$presence.points, 100000)
plot(test2)
plot(test)
plot(test2)
plot(test2, add = TRUE)
plot(test, add = TRUE)
test <- background.shape.buffer(ahli$presence.points, radius = 100000)
plot(test2)
plot(test, add = TRUE)
test2 <- background.shape.buffer(allogus$presence.points, 50000)
test <- background.shape.buffer(ahli$presence.points, radius = 50000)
plot(test, add = TRUE)
plot(test2)
plot(test, add = TRUE)
raster(test)
plot(raster(test))
env.files <- list.files(path = "testdata/", pattern = "pc*.asc")
env.files
env.files <- list.files(path = "testdata/", pattern = "pc")
env.files
env <- stack(env.files)
env.files <- list.files(path = "testdata/", pattern = "pc", full.names = TRUE)
env <- stack(env.files)
plot(env)
plove(env[[1]])
plot(env[[1]])
plot(test, add = TRUE)
plot(test2, add = TRUE)
#' Takes a set of points, a buffer radius, a sample size, and a mask and returns
#' randomly sampled points from within that buffer radius.
#' Code modified from Elith and Hijmans SDM with R tutorial
#'
#' @param points A two column data frame with X and Y coordinates
#' @param radius Radius for circular buffers to draw around points, in meters.
#' @param n Sample size for number of background points to return
#' @param mask A raster to use as a mask for drawing points
#'
#' @export background.points.buffer
background.points.buffer <- function(points, radius, n, mask = NA){
x <- circles(points, d=radius, lonlat=TRUE)
pol <-  gUnaryUnion(x@polygons)
if(!is.na(mask)){
buffer.raster <- mask(mask, pol)
} else {
buffer.raster <- rasterize(pol)
}
xy <- sampleRandom(buffer.raster, size=n, xy=TRUE)
colnames(xy)[1:2] <- c("lon", "lat")
return(xy[,1:2])
}
test3 <- background.points.buffer(ahli$presence.points, radius = 50000, n = 1000)
#' Takes a set of points, a buffer radius, a sample size, and a mask and returns
#' randomly sampled points from within that buffer radius.
#' Code modified from Elith and Hijmans SDM with R tutorial
#'
#' @param points A two column data frame with X and Y coordinates
#' @param radius Radius for circular buffers to draw around points, in meters.
#' @param n Sample size for number of background points to return
#' @param mask A raster to use as a mask for drawing points
#'
#' @export background.points.buffer
background.points.buffer <- function(points, radius, n, mask = NA){
x <- circles(points, d=radius, lonlat=TRUE)
pol <-  gUnaryUnion(x@polygons)
buffer.raster <- mask(mask, pol)
xy <- sampleRandom(buffer.raster, size=n, xy=TRUE)
colnames(xy)[1:2] <- c("lon", "lat")
return(xy[,1:2])
}
test3 <- background.points.buffer(ahli$presence.points, radius = 50000, n = 1000, env)
help(rasterize)
plot(test3)
test4 <- rasterize(test2, env)
plot(test4)
plot(env[[1]])
plot(test4, add = TRUE)
test5 <- intersect(env, test4)
test5
plot(test5)
library(ENMTools)
test6 <- background.raster.buffer(ahli$presence.points, 50000, env)
plot(test6)
length(env)
names(env)
#' Takes a set of points, a buffer radius, a sample size, and a mask and returns
#' randomly sampled points from within that buffer radius.
#' Code modified from Elith and Hijmans SDM with R tutorial
#'
#' @param points A two column data frame with X and Y coordinates
#' @param radius Radius for circular buffers to draw around points, in meters.
#' @param mask A raster to use as a mask
#'
#' @export background.raster.buffer
background.raster.buffer <- function(points, radius, mask){
x <- circles(points, d=radius, lonlat=TRUE)
pol <-  gUnaryUnion(x@polygons)
if(length(names(mask)) > 1){
mask <- mask[[1]]
}
buffer.raster <- mask(mask, pol)
buffer.raster[!is.na(buffer.raster)] <- 1
return(buffer.raster)
}
test6 <- background.raster.buffer(ahli$presence.points, 50000, env)
plot(test6)
test6 <- background.raster.buffer(ahli$presence.points, 50000, env[[1]])
plot(test6)
ahli$species.name
library(ENMTools)
setwd("~/GitHub/ENMTools/test")
library(ENMTools)
env.files <- list.files(path = "testdata/", pattern = "pc", full.names = TRUE)
env <- stack(env.files)
ahli <- enmtools.species()
check.species(ahli)
allogus <- enmtools.species(species.name = "allogus", presence.points = read.csv("testdata/allogus.csv")[,3:4])
check.species(allogus)
ahli <- enmtools.species(species.name = "ahli", presence.points = read.csv("testdata/ahli.csv")[,3:4])
check.species(ahli)
ahli$range <- background.raster.buffer(ahli$presence.points, 50000, mask = env)
allogus$range <- background.raster.buffer(allogus$presence.points, 50000, mask = env)
two.anoles <- enmtools.clade(list(ahli, allogus))
two.anoles
check.clade(two.anoles)
class(ahli$range)
"raster" %in% class(ahli$range)
"raster" %in% class(ahli$range)[1]
"raster" %in% class(ahli$range)[[1]]
"RasterLayer" %in% class(ahli$range)
setwd("~/GitHub/ENMTools/test")
library(ENMTools)
library(ENMTools)
env.files <- list.files(path = "testdata/", pattern = "pc", full.names = TRUE)
env <- stack(env.files)
ahli <- enmtools.species()
check.species(ahli)
allogus <- enmtools.species(species.name = "allogus", presence.points = read.csv("testdata/allogus.csv")[,3:4])
check.species(allogus)
ahli <- enmtools.species(species.name = "ahli", presence.points = read.csv("testdata/ahli.csv")[,3:4])
check.species(ahli)
ahli$range <- background.raster.buffer(ahli$presence.points, 50000, mask = env)
allogus$range <- background.raster.buffer(allogus$presence.points, 50000, mask = env)
two.anoles <- enmtools.clade(list(ahli, allogus))
two.anoles
check.clade(two.anoles)
rm(list=ls(all = TRUE))
library(ENMTools)
#' Takes a set of points, a buffer radius, a sample size, and a mask and returns
#' randomly sampled points from within that buffer radius.
#' Code modified from Elith and Hijmans SDM with R tutorial
setwd("~/GitHub/ENMTools/test")
library(ENMTools)
env.files <- list.files(path = "testdata/", pattern = "pc", full.names = TRUE)
env <- stack(env.files)
ahli <- enmtools.species()
check.species(ahli)
allogus <- enmtools.species(species.name = "allogus", presence.points = read.csv("testdata/allogus.csv")[,3:4])
check.species(allogus)
ahli <- enmtools.species(species.name = "ahli", presence.points = read.csv("testdata/ahli.csv")[,3:4])
check.species(ahli)
ahli$range <- background.raster.buffer(ahli$presence.points, 50000, mask = env)
allogus$range <- background.raster.buffer(allogus$presence.points, 50000, mask = env)
two.anoles <- enmtools.clade(list(ahli, allogus))
two.anoles
check.clade(two.anoles)
check.clade(two.anoles)
# NOTE TO SELF: started off passing a vector of args to insist on to make testing easier,
# but this quickly turned into a nightmare.  We'll just check the existence of the important
# bits manually before each analysis.
check.clade(two.anoles)
two.anoles
names(two.anoles)
names(two.anoles$species)
library(rwty)
data(fungus)
test <- analyze.rwty(fungus, burnin=20)
test$LnL.trace
test$TL.trace
test$Fungus.Run1.correlations
