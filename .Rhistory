pred.p <- as.numeric(predict(model, data.frame(p.table), type = "response"))
pred.bg <- as.numeric(predict(model, data.frame(bg.table), type = "response"))
env.evaluation <- evaluate(pred.p, pred.bg)
return(env.evaluation)
}
test <- env.evaluate(allogus, allogus.glm, env)
env
#' Calculates evaluation metrics (AUC, etc.) using latin hypercube sampling in environment space
#'
#' @param species An enmtools.species object
#' @param model An enmtools.model object or a model that can be projected using the predict() function of dismo
#' @param env A raster or raster stack of environmental data.
#' @param bg.source Determines whether minima and maxima of the environment space should be picked using the environment layers or the background points.
#' @param ... Arguments to be passed to othfer functions
#'
#' @export env.evaluate
env.evaluate <- function(species, model, env, bg.source = "background", ...){
species <- check.bg(species, env, ...)
if(!inherits(species, "enmtools.species")){
stop("Argument species must supply an enmtools.species object!")
}
presence <- species$presence.points[,1:2]
background <- species$background.points[,1:2]
if(inherits(model, "enmtools.model")){
model <- model$model
}
if(bg.source == "background"){
allpoints <- rbind(presence, background)
values <- extract(env, allpoints)
maxes <- apply(values, 2, function(x) max(x, na.rm = TRUE))
mins <- apply(values, 2, function(x) max(x, na.rm = TRUE))
}
if(bg.source == "env") {
maxes <- maxValue(env)
mins <- minValue(env)
}
this.lhs <- randomLHS(10000, length(names(env)))
bg.table <- t(t(this.lhs) * (maxes  - mins) + mins)
print(head(bg.table))
colnames(bg.table) <- names(env)
p.table <- extract(env, presence)
#
#   print(mins)
#   print(maxes)
#   print(head(bg.table))
#   print(head(p.table))
pred.p <- as.numeric(predict(model, data.frame(p.table), type = "response"))
pred.bg <- as.numeric(predict(model, data.frame(bg.table), type = "response"))
env.evaluation <- evaluate(pred.p, pred.bg)
return(env.evaluation)
}
test <- env.evaluate(allogus, allogus.glm, env)
#' Calculates evaluation metrics (AUC, etc.) using latin hypercube sampling in environment space
#'
#' @param species An enmtools.species object
#' @param model An enmtools.model object or a model that can be projected using the predict() function of dismo
#' @param env A raster or raster stack of environmental data.
#' @param bg.source Determines whether minima and maxima of the environment space should be picked using the environment layers or the background points.
#' @param ... Arguments to be passed to othfer functions
#'
#' @export env.evaluate
env.evaluate <- function(species, model, env, bg.source = "background", ...){
species <- check.bg(species, env, ...)
if(!inherits(species, "enmtools.species")){
stop("Argument species must supply an enmtools.species object!")
}
presence <- species$presence.points[,1:2]
background <- species$background.points[,1:2]
if(inherits(model, "enmtools.model")){
model <- model$model
}
if(bg.source == "background"){
allpoints <- rbind(presence, background)
values <- extract(env, allpoints)
maxes <- apply(values, 2, function(x) max(x, na.rm = TRUE))
mins <- apply(values, 2, function(x) max(x, na.rm = TRUE))
}
if(bg.source == "env") {
maxes <- maxValue(env)
mins <- minValue(env)
}
this.lhs <- randomLHS(10000, length(names(env)))
bg.table <- t(t(this.lhs) * (maxes  - mins) + mins)
colnames(bg.table) <- names(env)
p.table <- extract(env, presence)
#
#   print(mins)
#   print(maxes)
#   print(head(bg.table))
#   print(head(p.table))
pred.p <- as.numeric(predict(model, data.frame(p.table), type = "response"))
pred.bg <- as.numeric(predict(model, data.frame(bg.table), type = "response"))
env.evaluation <- evaluate(pred.p, pred.bg)
return(eval = env.evaluation,
lhs = this.lhs,
maxes = maxes,
mins = mins)
}
test <- env.evaluate(allogus, allogus.glm, env)
#' Calculates evaluation metrics (AUC, etc.) using latin hypercube sampling in environment space
#'
#' @param species An enmtools.species object
#' @param model An enmtools.model object or a model that can be projected using the predict() function of dismo
#' @param env A raster or raster stack of environmental data.
#' @param bg.source Determines whether minima and maxima of the environment space should be picked using the environment layers or the background points.
#' @param ... Arguments to be passed to othfer functions
#'
#' @export env.evaluate
env.evaluate <- function(species, model, env, bg.source = "background", ...){
species <- check.bg(species, env, ...)
if(!inherits(species, "enmtools.species")){
stop("Argument species must supply an enmtools.species object!")
}
presence <- species$presence.points[,1:2]
background <- species$background.points[,1:2]
if(inherits(model, "enmtools.model")){
model <- model$model
}
if(bg.source == "background"){
allpoints <- rbind(presence, background)
values <- extract(env, allpoints)
maxes <- apply(values, 2, function(x) max(x, na.rm = TRUE))
mins <- apply(values, 2, function(x) max(x, na.rm = TRUE))
}
if(bg.source == "env") {
maxes <- maxValue(env)
mins <- minValue(env)
}
this.lhs <- randomLHS(10000, length(names(env)))
bg.table <- t(t(this.lhs) * (maxes  - mins) + mins)
colnames(bg.table) <- names(env)
p.table <- extract(env, presence)
#
#   print(mins)
#   print(maxes)
#   print(head(bg.table))
#   print(head(p.table))
pred.p <- as.numeric(predict(model, data.frame(p.table), type = "response"))
pred.bg <- as.numeric(predict(model, data.frame(bg.table), type = "response"))
env.evaluation <- evaluate(pred.p, pred.bg)
return(list(eval = env.evaluation,
lhs = this.lhs,
maxes = maxes,
mins = mins))
}
test <- env.evaluate(allogus, allogus.glm, env)
t(t(test$lhs) * (maxes - mins) + mins)
library(ENMTools)
test <- env.evaluate(allogus, allogus.glm, env)
test
library(ENMTools)
test <- env.evaluate(allogus, allogus.glm, env)
library(ENMTools)
test
#' Calculates evaluation metrics (AUC, etc.) using latin hypercube sampling in environment space
#'
#' @param species An enmtools.species object
#' @param model An enmtools.model object or a model that can be projected using the predict() function of dismo
#' @param env A raster or raster stack of environmental data.
#' @param bg.source Determines whether minima and maxima of the environment space should be picked using the environment layers or the background points.
#' @param ... Arguments to be passed to othfer functions
#'
#' @export env.evaluate
env.evaluate <- function(species, model, env, bg.source = "background", ...){
species <- check.bg(species, env, ...)
if(!inherits(species, "enmtools.species")){
stop("Argument species must supply an enmtools.species object!")
}
presence <- species$presence.points[,1:2]
background <- species$background.points[,1:2]
if(inherits(model, "enmtools.model")){
model <- model$model
}
if(bg.source == "background"){
allpoints <- rbind(presence, background)
values <- extract(env, allpoints)
maxes <- apply(values, 2, function(x) max(x, na.rm = TRUE))
mins <- apply(values, 2, function(x) min(x, na.rm = TRUE))
}
if(bg.source == "env") {
maxes <- maxValue(env)
mins <- minValue(env)
}
this.lhs <- randomLHS(10000, length(names(env)))
bg.table <- t(t(this.lhs) * (maxes  - mins) + mins)
colnames(bg.table) <- names(env)
p.table <- extract(env, presence)
#
#   print(mins)
#   print(maxes)
#   print(head(bg.table))
#   print(head(p.table))
pred.p <- as.numeric(predict(model, data.frame(p.table), type = "response"))
pred.bg <- as.numeric(predict(model, data.frame(bg.table), type = "response"))
env.evaluation <- evaluate(pred.p, pred.bg)
return(env.evaluation)
}
test <- env.evaluate(allogus, allogus.glm, env)
test
test <- env.evaluate(allogus, allogus.dm, env)
test
library(ENMTools)
setwd("~/GitHub/ENMTools/test")
library(ENMTools)
# This code builds the readme.rmd file into a regular md file, which GitHub understands better
# knit(input="~/GitHub/ENMTools/Readme.Rmd", output = "~/GitHub/ENMTools/readme.md")
env.files <- list.files(path = "testdata/", pattern = "pc", full.names = TRUE)
env <- stack(env.files)
names(env) <- c("layer.1", "layer.2", "layer.3", "layer.4")
env <- setMinMax(env)
ahli <- enmtools.species()
check.species(ahli)
allogus <- enmtools.species(species.name = "allogus", presence.points = read.csv("testdata/allogus.csv")[,3:4])
check.species(allogus)
ahli <- enmtools.species(species.name = "ahli", presence.points = read.csv("testdata/ahli.csv")[,3:4])
check.species(ahli)
ahli$range <- background.raster.buffer(ahli$presence.points, 50000, mask = env)
allogus$range <- background.raster.buffer(allogus$presence.points, 50000, mask = env)
ahli$background.points <- background.points.buffer(points = ahli$presence.points,radius = 40000, n = 1000, mask = env[[1]])
allogus$background.points <- background.points.buffer(points = allogus$presence.points,radius = 40000, n = 1000, mask = env[[1]])
colnames(ahli$background.points) <- colnames(ahli$presence.points)
colnames(allogus$background.points) <- colnames(allogus$presence.points)
args <- c("betamultiplier=0.5", "product=FALSE", "hinge=FALSE", "threshold=FALSE")
args <- c("betamultiplier=0.5", "product=FALSE", "hinge=FALSE", "threshold=FALSE")
allogus.mx.args <- enmtools.maxent(allogus, env[[c("layer.1", "layer.4")]], test.prop = 0.2, args)
allogus.mx.args
plot(allogus.mx.args)
setwd("~/GitHub/ENMTools/test")
library(ENMTools)
# This code builds the readme.rmd file into a regular md file, which GitHub understands better
# knit(input="~/GitHub/ENMTools/Readme.Rmd", output = "~/GitHub/ENMTools/readme.md")
env.files <- list.files(path = "testdata/", pattern = "pc", full.names = TRUE)
env <- stack(env.files)
names(env) <- c("layer.1", "layer.2", "layer.3", "layer.4")
env <- setMinMax(env)
ahli <- enmtools.species()
check.species(ahli)
allogus <- enmtools.species(species.name = "allogus", presence.points = read.csv("testdata/allogus.csv")[,3:4])
check.species(allogus)
ahli <- enmtools.species(species.name = "ahli", presence.points = read.csv("testdata/ahli.csv")[,3:4])
check.species(ahli)
ahli$range <- background.raster.buffer(ahli$presence.points, 50000, mask = env)
allogus$range <- background.raster.buffer(allogus$presence.points, 50000, mask = env)
ahli$background.points <- background.points.buffer(points = ahli$presence.points,radius = 40000, n = 1000, mask = env[[1]])
allogus$background.points <- background.points.buffer(points = allogus$presence.points,radius = 40000, n = 1000, mask = env[[1]])
colnames(ahli$background.points) <- colnames(ahli$presence.points)
colnames(allogus$background.points) <- colnames(allogus$presence.points)
two.anoles <- enmtools.clade(list(ahli, allogus))
two.anoles <- check.clade(two.anoles)
two.anoles
summary(ahli)
print(ahli)
plot(ahli)
summary(two.anoles)
plot(two.anoles)
ahli.glm <- enmtools.glm(ahli, env, pres ~ layer.1 + layer.2 + layer.3 + layer.4, test.prop = 0.2)
ahli.glm
ahli.glm$response.plots
ahli.gam <- enmtools.gam(ahli, env, test.prop = 0.2, k = 10)
ahli.gam
ahli.gam$response.plots
visualize.enm(ahli.gam, env, layers = c("layer.1", "layer.2"))
onevar.glm <- enmtools.glm(ahli, env, pres ~ layer.1, test.prop = 0.2)
onevar.glm
onevar.glm$response.plots
allogus.glm <- enmtools.glm(allogus, env, pres ~ layer.1 + layer.2 + layer.3 + layer.4)
allogus.glm
allogus.glm <- enmtools.glm(allogus, env, pres ~ layer.1 + layer.2 + layer.3 + layer.4, test.prop = 0.3)
allogus.glm
env.plots <- visualize.enm(allogus.glm, env, layers = c("layer.1", "layer.2"))
env.plots
ahli.twovar.glm <- enmtools.glm(ahli, env, pres ~ layer.1 + layer.4)
ahli.twovar.glm
ahli.bc <- enmtools.bc(ahli, env, test.prop = 0.2)
ahli.bc
ahli.bc$response.plots
ahli.bc2 <- enmtools.bc(ahli, env[[c("layer.1", "layer.4")]])
ahli.mx <- enmtools.maxent(ahli, env, test.prop = 0.2)
ahli.mx
ahli.mx$response.plots
allogus.mx <- enmtools.maxent(allogus, env[[c("layer.1", "layer.4")]], test.prop = 0.2)
allogus.mx
allogus.mx$response.plots
args <- c("betamultiplier=0.5", "product=FALSE", "hinge=FALSE", "threshold=FALSE")
allogus.mx.args <- enmtools.maxent(allogus, env[[c("layer.1", "layer.4")]], test.prop = 0.2, args)
allogus.mx.args
allogus.mx.args$response.plots
allogus.mx.args$model
allogus.mx.args <- enmtools.maxent(allogus, env, test.prop = 0.2, betamultiplier=0.5, product=FALSE, hinge=FALSE, threshold=FALSE)
allogus.mx.args$model
help(maxent)
test <- maxent(env, allogus$presence.points, allogus$background.points, , betamultiplier=0.5, product=FALSE, hinge=FALSE, threshold=FALSE)
test <- maxent(x = env, p = allogus$presence.points, a = allogus$background.points, , betamultiplier=0.5, product=FALSE, hinge=FALSE, threshold=FALSE)
args <- c("betamultiplier=0.5", "product=FALSE", "hinge=FALSE", "threshold=FALSE")
allogus.mx.args <- enmtools.maxent(allogus, env, test.prop = 0.2, args)
fnames <- list.files(path=paste(system.file(package="dismo"), '/ex', sep=''),
pattern='grd', full.names=TRUE )
predictors <- stack(fnames)
occurence <- paste(system.file(package="dismo"), '/ex/bradypus.csv', sep='')
occ <- read.table(occurence, header=TRUE, sep=',')[,-1]
fold <- kfold(occ, k=5)
occtest <- occ[fold == 1, ]
occtrain <- occ[fold != 1, ]
me2 <- maxent(predictors, occtrain, factors='biome', args=c("-J", "-P"))
me2
me2 <- maxent(predictors, occtrain, factors='biome', args=args)
me2
allogus.mx.args <- enmtools.maxent(allogus, env, test.prop = 0.2, args = args)
allogus.mx.args
allogus.mx.args$response.plots
allogus.mx.args
allogus.mx.args$model
allogus.mx.args$model
library(ENMTools)
setwd("~/GitHub/ENMTools/test")
Sys.setenv(NOAWT=TRUE)
library(ENMTools)
# This code builds the readme.rmd file into a regular md file, which GitHub understands better
# knit(input="~/GitHub/ENMTools/Readme.Rmd", output = "~/GitHub/ENMTools/readme.md")
env.files <- list.files(path = "testdata/", pattern = "pc", full.names = TRUE)
env <- stack(env.files)
names(env) <- c("layer.1", "layer.2", "layer.3", "layer.4")
env <- setMinMax(env)
ahli <- enmtools.species()
check.species(ahli)
allogus <- enmtools.species(species.name = "allogus", presence.points = read.csv("testdata/allogus.csv")[,3:4])
check.species(allogus)
ahli <- enmtools.species(species.name = "ahli", presence.points = read.csv("testdata/ahli.csv")[,3:4])
check.species(ahli)
ahli$range <- background.raster.buffer(ahli$presence.points, 50000, mask = env)
allogus$range <- background.raster.buffer(allogus$presence.points, 50000, mask = env)
ahli$background.points <- background.points.buffer(points = ahli$presence.points,radius = 40000, n = 1000, mask = env[[1]])
allogus$background.points <- background.points.buffer(points = allogus$presence.points,radius = 40000, n = 1000, mask = env[[1]])
colnames(ahli$background.points) <- colnames(ahli$presence.points)
colnames(allogus$background.points) <- colnames(allogus$presence.points)
two.anoles <- enmtools.clade(list(ahli, allogus))
two.anoles <- check.clade(two.anoles)
two.anoles
summary(ahli)
print(ahli)
plot(ahli)
summary(two.anoles)
plot(two.anoles)
ahli.glm <- enmtools.glm(ahli, env, pres ~ layer.1 + layer.2 + layer.3 + layer.4, test.prop = 0.2)
ahli.glm
enmtools.glm
ahli.glm$response.plots
ahli.gam <- enmtools.gam(ahli, env, test.prop = 0.2, k = 10)
ahli.gam
ahli.gam$response.plots
visualize.enm(ahli.gam, env, layers = c("layer.1", "layer.2"))
onevar.glm <- enmtools.glm(ahli, env, pres ~ layer.1, test.prop = 0.2)
onevar.glm
onevar.glm$response.plots
allogus.glm <- enmtools.glm(allogus, env, pres ~ layer.1 + layer.2 + layer.3 + layer.4)
allogus.glm
allogus.glm <- enmtools.glm(allogus, env, pres ~ layer.1 + layer.2 + layer.3 + layer.4, test.prop = 0.3)
allogus.glm
env.plots <- visualize.enm(allogus.glm, env, layers = c("layer.1", "layer.2"))
env.plots
ahli.twovar.glm <- enmtools.glm(ahli, env, pres ~ layer.1 + layer.4)
ahli.twovar.glm
ahli.bc <- enmtools.bc(ahli, env, test.prop = 0.2)
ahli.bc
ahli.bc$response.plots
ahli.bc2 <- enmtools.bc(ahli, env[[c("layer.1", "layer.4")]])
ahli.mx <- enmtools.maxent(ahli, env, test.prop = 0.2)
ahli.mx
ahli.mx$response.plots
allogus.mx <- enmtools.maxent(allogus, env[[c("layer.1", "layer.4")]], test.prop = 0.2)
allogus.mx
allogus.mx$response.plots
args <- c("betamultiplier=0.5", "product=FALSE", "hinge=FALSE", "threshold=FALSE")
allogus.mx.args <- enmtools.maxent(allogus, env, test.prop = 0.2, args = args)
allogus.mx.args
allogus.mx.args$response.plots
allogus.dm <- enmtools.dm(allogus, env, test.prop = 0.2)
allogus.dm
env.evaluate(allogus, allogus.dm, env, "background")
visualize.enm(allogus.dm, env, layers = c("layer.1", "layer.2"))
ahli.dm <- enmtools.dm(ahli, env, test.prop = 0.2)
test <- read.csv("~/OneDrive/R Projects/Banksia ARC/NNClusterArc/Banksia PC.csv")
head(test)
require(fields)  # Used for Euclidean distance matrices
nncluster <- function(xy, species){
species <- as.factor(species)
levs <- levels(species)
df <- as.data.frame(matrix (nrow=length(levels(species)), ncol=length(levels(species))))
rownames(df) <- levels(species)
colnames(df) <- levels(species)
for(i in 1:length(levs)){
for(j in i:length(levs)){
if(i != j){
if(nrow(xy[species == levs[i],]) > 1 && nrow(xy[species == levs[j],]) > 1){
print(paste("Calculating", levs[i], "vs", levs[j]))
within1 <- rdist(xy[species == levs[i],],xy[species == levs[i],])
within2 <- rdist(xy[species == levs[j],],xy[species == levs[j],])
between <- rdist(xy[species == levs[i],],xy[species == levs[j],])
score1 <- rep(NA,length(within1[1,]))
score2 <- rep(NA,length(within1[2,]))
for(k in 1:length(within1[1,])){
thisscore <- min(within1[k,-(k)])/min(between[k,])
score1[k] <- thisscore
}
for(k in 1:length(within2[1,])){
thisscore <- min(within2[k,-(k)])/min(between[,k])
score2[k] <- thisscore
}
score1 <- length(which(score1>1))/length(score1)
score2 <- length(which(score2>1))/length(score2)
w <- mean(c(score1, score2))
}
else{w <- NA}
df[i,j] <- w
}
}
}
return( df)
}
install.packages("fields")
test$Species
unique(test$Species)
require(fields)  # Used for Euclidean distance matrices
nncluster <- function(xy, species){
species <- as.factor(species)
levs <- levels(species)
df <- as.data.frame(matrix (nrow=length(levels(species)), ncol=length(levels(species))))
rownames(df) <- levels(species)
colnames(df) <- levels(species)
for(i in 1:length(levs)){
for(j in i:length(levs)){
if(i != j){
if(nrow(xy[species == levs[i],]) > 1 && nrow(xy[species == levs[j],]) > 1){
print(paste("Calculating", levs[i], "vs", levs[j]))
within1 <- rdist(xy[species == levs[i],],xy[species == levs[i],])
within2 <- rdist(xy[species == levs[j],],xy[species == levs[j],])
between <- rdist(xy[species == levs[i],],xy[species == levs[j],])
score1 <- rep(NA,length(within1[1,]))
score2 <- rep(NA,length(within1[2,]))
for(k in 1:length(within1[1,])){
thisscore <- min(within1[k,-(k)])/min(between[k,])
score1[k] <- thisscore
}
for(k in 1:length(within2[1,])){
thisscore <- min(within2[k,-(k)])/min(between[,k])
score2[k] <- thisscore
}
score1 <- length(which(score1>1))/length(score1)
score2 <- length(which(score2>1))/length(score2)
w <- mean(c(score1, score2))
}
else{w <- NA}
df[i,j] <- w
}
}
}
return( df)
}
test2 <- nncluster(test[,c("Longitude", "Latitude")], test[,"Species"])
head(test2)
length(unique(test$Species))
length(unique(test$Longitude))
require(fields)  # Used for Euclidean distance matrices
# xy is a two-columnmatrix of x and y values
# species is a vector of species names of the same length as ncol(xy)
nncluster <- function(xy, species){
# Figure out how many species we've got, initialize a data frame
species.names <- unique(species)
df <- as.data.frame(matrix (nrow=length(species.names), ncol=length(species.names)))
rownames(df) <- species.names
colnames(df) <- species.names
# Do each pair of species
for(i in 1:length(species.names)){
for(j in i:length(species.names)){
if(i != j){
# Need at least two points to calculate
if(nrow(xy[species == species.names[i],]) > 1 && nrow(xy[species == species.names[j],]) > 1){
print(paste("Calculating", species.names[i], "vs", species.names[j]))
within1 <- rdist(xy[species == species.names[i],],xy[species == species.names[i],])
within2 <- rdist(xy[species == species.names[j],],xy[species == species.names[j],])
between <- rdist(xy[species == species.names[i],],xy[species == species.names[j],])
score1 <- rep(NA,length(within1[1,]))
score2 <- rep(NA,length(within1[2,]))
for(k in 1:length(within1[1,])){
thisscore <- min(within1[k,-(k)])/min(between[k,])
score1[k] <- thisscore
}
for(k in 1:length(within2[1,])){
thisscore <- min(within2[k,-(k)])/min(between[,k])
score2[k] <- thisscore
}
score1 <- length(which(score1>1))/length(score1)
score2 <- length(which(score2>1))/length(score2)
w <- mean(c(score1, score2))
}
else{w <- NA}
df[i,j] <- w
}
}
}
return( df)
}
test2 <- nncluster(test[,c("Longitude", "Latitude")], test[,"Species"])
ahli$presence.points
library(rwty)
data(fungus)
rwty.plots <- analyze.rwty(fungus, burnin = 25)
rwty.plots$treespace.points.plot
rwty.plots$treespace.points.plot$data
qplot(x, y, data = rwty.plots$treespace.points.plot$data, color = chain)
qplot(x, y, data = rwty.plots$treespace.points.plot$data, color = chain) + theme_classic()
qplot(x, y, data = rwty.plots$treespace.points.plot$data, color = chain) + theme_bw()
