if (identical(sort(as.integer(nds)), sort(as.integer(tips)))){
# Clade is a terminal sister pair
mult <- 1
} else if (all(tree$edge[which(tree$edge[,2] %in% tips), 1] == tree$edge[which(tree$edge[,2] %in% tips), 1][1])){
# Clade includes both terminal taxa but is a polytomy
mult <- 1/(choose(length(which(tree$edge[,1] == mrca)), 2))
} else {
# Not a polytomy, not a sister pair
# Get internal nodes
nds <- nds[nds > ntips]
# Figure out how many daughters each node has
daughters <- sapply(nds, function(x) length(which(tree$edge[,1] == x)))
# Trim it down to the number of daughters per node that falls along path between tips
check <- function(x, tips) any(tips %in% descendants(tree, x))
id <- sapply(nds, check, tips = tips)
mult <- 1/prod(daughters[id]) * 1/(choose(length(which(tree$edge[,1] == mrca)), 2))
}
return(mult)
}
node.overlap(overlap = test.overlap, tree = test.tree)
test.tree <- compute.brlen(rtree(20))
test.overlap <- matrix(data = runif(400), nrow = 20, ncol = 20)
colnames(test.overlap) <- rownames(test.overlap) <- test.tree$tip.label
system.time(test1 <- node.overlap(overlap = test.overlap, tree = test.tree))
system.time(test2 <- age.range.correlation(test.tree, test.overlap, n = 1)$age.range.correlation)
test1[,2] == test2[,2]
ntax <- rep(seq(4, 100, by = 4), 2)
newtimes <- rep(NA, length(ntax))
oldtimes <- rep(NA, length(ntax))
for(i in 1:length(ntax)){
print(ntax[i])
this.tree <- compute.brlen(rtree(ntax[i]))
this.overlap <- matrix(data = runif(ntax[i] ** 2), nrow = ntax[i], ncol = ntax[i])
colnames(test.overlap) <- rownames(test.overlap) <- test.tree$tip.label
newtimes[i] <- system.time(node.overlap(overlap = test.overlap, tree = test.tree))[3]
oldtimes[i] <- system.time(age.range.correlation(test.tree, test.overlap, n = 1)$age.range.correlation)[3]
}
qplot(oldtimes, newtimes)
newtimes/oldtimes
mean(newtimes/oldtimes)
max(newtimes/oldtimes)
daughters
daughters <- tree$edge[tree$edge[, 1] == 12, 2]
daughters
tree$edge[tree$edge[, 1] == 15, 2]
tree$edge[tree$edge[, 1] == 16, 2]
tree$edge[tree$edge[, 1] == 21, 2]
tree$edge[tree$edge[, 1] == 22, 2]
test.tree$edge[tree$edge[, 1] == 22, 2]
test.tree$edge[test.tree$edge[, 1] == 22, 2]
test.tree$edge[test.tree$edge[, 1] == 21, 2]
mclapply
help(mclapply)
mc.cores
comparisons
nds
tips
rm(list=ls())
library(testthat)
library(rwty)
#############################################################
#
#     Single chain analysis
#
#############################################################
# Load in test trees
test.trees <- load.trees("~/GitHub/RWTY/test/testchain.t", skip=0)
clade.freq(test.trees, 1, 16)
# 1  1 2 3 4 5 6 7 8 9 10       1.00
# 2              1 8 9 10       1.00
# 3        1 5 6 7 8 9 10       1.00
# 4      1 2 5 6 7 8 9 10       0.50
# 5        1 2 3 4 8 9 10       1.00
# 6      1 2 3 4 7 8 9 10       1.00
# 7         1 2 3 4 5 6 7       1.00
# 8       1 2 3 4 5 6 7 8       0.25
# 9      1 3 5 6 7 8 9 10       0.50
# 10      1 2 3 4 5 6 7 9       0.75
# Evaluate the trees object
expect_equal(names(test.trees), c("trees", "ptable", "gens.per.tree"))
expect_equal(length(names(test.trees$trees)), 16)
expect_equal(names(test.trees$trees), c("tree_0", "tree_100", "tree_200", "tree_300",
"tree_400", "tree_500", "tree_600", "tree_700",
"tree_800", "tree_900", "tree_1000", "tree_1100",
"tree_1200", "tree_1300", "tree_1400", "tree_1500"))
expect_equal(test.trees$gens.per.tree, 100)
# Get output from RWTY for test trees object
test.output <- analyze.rwty(test.trees, window.num=4, treespace.points=4, autocorr.intervals = 4, burnin=0)
test.trees
test.output <- analyze.rwty(test.trees, window.size=4, treespace.points=4, autocorr.intervals = 4, burnin=0)
test.output <- analyze.rwty(test.trees, window.size=2, treespace.points=4, autocorr.intervals = 4, burnin=0)
test.output <- analyze.rwty(test.trees, window.size=2, treespace.points=2, autocorr.intervals = 4, burnin=0)
test.output <- analyze.rwty(test.trees, window.size=4, treespace.points=4, autocorr.intervals = 4, burnin=0)
warnings()
test.output <- analyze.rwty(test.trees, window.size=1, treespace.points=4, autocorr.intervals = 4, burnin=0)
test.trees <- load.trees("~/GitHub/RWTY/test/testchain.t", skip=0)
clade.freq(test.trees, 1, 16)
expect_equal(names(test.trees), c("trees", "ptable", "gens.per.tree"))
expect_equal(length(names(test.trees$trees)), 16)
expect_equal(length(names(test.trees$trees)), 31)
xpect_equal(names(test.trees$trees), c("tree_0", "tree_100", "tree_200", "tree_300",
"tree_400", "tree_500", "tree_600", "tree_700",
"tree_800", "tree_900", "tree_1000", "tree_1100",
"tree_1200", "tree_1300", "tree_1400", "tree_1500",
"tree_1600", "tree_1700", "tree_1800", "tree_1900",
"tree_2000", "tree_2100", "tree_2200", "tree_2300",
"tree_2400", "tree_2500", "tree_2600", "tree_2700",
"tree_2800", "tree_2900", "tree_3000"))
expect_equal(test.trees$gens.per.tree, 100)
expect_equal(names(test.trees$trees), c("tree_0", "tree_100", "tree_200", "tree_300",
"tree_400", "tree_500", "tree_600", "tree_700",
"tree_800", "tree_900", "tree_1000", "tree_1100",
"tree_1200", "tree_1300", "tree_1400", "tree_1500",
"tree_1600", "tree_1700", "tree_1800", "tree_1900",
"tree_2000", "tree_2100", "tree_2200", "tree_2300",
"tree_2400", "tree_2500", "tree_2600", "tree_2700",
"tree_2800", "tree_2900", "tree_3000"))
expect_equal(test.trees$gens.per.tree, 100)
# Get output from RWTY for test trees object
test.output <- analyze.rwty(test.trees, window.size=4, treespace.points=4, autocorr.intervals = 4, burnin=0)
test.output <- analyze.rwty(test.trees, window.size=4, treespace.points=4, autocorr.intervals = 2, burnin=0)
warnings()
test.output <- analyze.rwty(test.trees, window.size=4, treespace.points=4, autocorr.intervals = 2, burnin=0, max.sampling.interval = 4)
warnings()
test.output <- analyze.rwty(test.trees, window.size=4, treespace.points=4, autocorr.intervals = 2, burnin=0, max.sampling.interval = 3)
test.output <- analyze.rwty(test.trees, window.size=4, treespace.points=4, autocorr.intervals = 2, burnin=0, max.sampling.interval = 2)
test.output <- analyze.rwty(test.trees, window.size=4, treespace.points=4, autocorr.intervals = 4, max.sampling.interval = 4, burnin=0)
warnings()
length(test.trees[[1]])
length(test.trees[[1]]$trees)
class(test.trees)
test.trees <- load.multi("~/GitHub/RWTY/test/", ext.tree = "t", skip=0)
test.trees <- load.multi("~/GitHub/RWTY/test/",  skip=0)
class(test.trees)
test.trees <- load.trees("~/GitHub/RWTY/test/testchain.t", skip=0)
test.trees[[1]]
length(test.trees[[1]])
#' Calculate the approximate Effective Sample Size (ESS) of tree topologies
#'
#' This function takes a list of rwty.trees objects, and calculates the
#' pseudo ESS of the trees from each chain, after removing burnin.
#' The calculation uses the autocorrelation among squared topological distances between
#' trees to calculate an approximate ESS of tree topologies for each chain.
#' NB this function requires the calculation of many many
#' tree distances, so can take some time.
#'
#' @param chains A list of rwty.trees objects.
#' @param burnin The number of trees to eliminate as burnin
#' @param max.sampling.interval The largest sampling interval you want to use to calculate the ESS. Every sampling interval up to and including this number will be sampled. Higher is better, but also slower. In general, setting this number to 100 (the default) should be fine for most cases. However, if you get an upper bound on the ESS estimate (i.e. ESS<x) rather than a point estimate (i.e. ESS = x) then that indicates a higher max.sampling.interval would be better, because the algorithm could not find the asymptote on the autocorrelation plot with the current max.sampling.interval.
#' @param treedist the type of tree distance metric to use, can be 'PD' for path distance or 'RF' for Robinson Foulds distance
#' @param use.all.samples (TRUE/FALSE). Whether to calculate autocorrelation from all possible pairs of trees in your chain. The default is FALSE, in which case 500 samples are taken at each sampling interval. Setting this to TRUE will give you slightly more accurate ESS estimates, at the cost of potentially much longer execution times.
#'
#' @return A data frame with one row per chain, and columns describing the
#' approximate ESS and the name of the chain.
#'
#' @keywords treespace, tree distance, path distance
#'
#' @export topological.approx.ess
#' @examples
#' \dontrun{
#' data(fungus)
#' topological.approx.ess(fungus, burnin = 20)
#' }
topological.approx.ess <- function(chains, burnin = 0, max.sampling.interval = 100, treedist = 'PD', use.all.samples = FALSE){
chains = check.chains(chains)
if(inherits(chains, "list")){
N = length(chains[[1]]$trees)
} else {
N = length(chains[[1]])
}
if(N-burnin < max.sampling.interval){
warning("Not enough trees to use your chosen max.sampling.interval")
warning("Setting it to 90% of the length of your post-burnin chain instead")
max.sampling.interval = floor((N - burnin) * 0.9)
}
# set them equal, so we get every interval.
autocorr.intervals = max.sampling.interval
print(sprintf("Calculating approximate ESS with sampling intervals from 1 to %d", max.sampling.interval))
autocorr.df = topological.autocorr(chains, burnin, max.sampling.interval, autocorr.intervals, squared = TRUE, treedist = treedist, use.all.samples = use.all.samples)
autocorr.m = estimate.autocorr.m(autocorr.df)
approx.ess.df = approx.ess.multi(autocorr.df, autocorr.m, (N-burnin))
return(approx.ess.df)
}
approx.ess.multi <- function(autocorr.df, autocorr.m, N){
# estimate the approximate ESS from squared topological distances,
# using a single chain
r = length(unique(autocorr.df$chain))
approx.ess.df = data.frame(operator = rep(NA, r), approx.ess = rep(NA, r), chain = unique(autocorr.df$chain))
# Loop over chains, calculate approx ess
for(i in 1:nrow(approx.ess.df)){
thischain = approx.ess.df$chain[i]
thism = autocorr.m$autocorr.time[autocorr.m$chain == thischain]
thisdata = autocorr.df[autocorr.df$chain == thischain,]
ess.info = approx.ess.single(thisdata, thism, N)
ess = ess.info$ess
operator = ess.info$operator
approx.ess.df$approx.ess[approx.ess.df$chain == thischain] = ess
approx.ess.df$operator[approx.ess.df$chain == thischain] = operator
}
return(approx.ess.df)
}
approx.ess.single <- function(df, autocorr.time, N){
# many thanks to Xia Hua and David Bryant for help with this
# if the autocorrelation time is larger than the maximum sample
# our it is recorded as -1
if(autocorr.time < 0){
m = nrow(df) + 1
}else{
m = autocorr.time
}
D = max(df$topo.distance)
S = 0
if(m>1){
for(k in 1:(m - 1)){
f = df$topo.distance[k]
S = S + ((N - k) * f)
}
}
S = S + (N - m + 1) * (N - m) * D / 2
S = S / 2 / N^2
ESS = 1 / (1 - 4 * S / D)
# sometimes we can only give an upper bound
if(autocorr.time<0){
operator = "<"
}else{
operator = "="
}
return(list("ess" = ESS, "operator" = operator))
}
test.output <- analyze.rwty(test.trees, window.size=4, treespace.points=4, autocorr.intervals = 4, max.sampling.interval = 4, burnin=0)
warnings()
#' Calculate the approximate Effective Sample Size (ESS) of tree topologies
#'
#' This function takes a list of rwty.trees objects, and calculates the
#' pseudo ESS of the trees from each chain, after removing burnin.
#' The calculation uses the autocorrelation among squared topological distances between
#' trees to calculate an approximate ESS of tree topologies for each chain.
#' NB this function requires the calculation of many many
#' tree distances, so can take some time.
#'
#' @param chains A list of rwty.trees objects.
#' @param burnin The number of trees to eliminate as burnin
#' @param max.sampling.interval The largest sampling interval you want to use to calculate the ESS. Every sampling interval up to and including this number will be sampled. Higher is better, but also slower. In general, setting this number to 100 (the default) should be fine for most cases. However, if you get an upper bound on the ESS estimate (i.e. ESS<x) rather than a point estimate (i.e. ESS = x) then that indicates a higher max.sampling.interval would be better, because the algorithm could not find the asymptote on the autocorrelation plot with the current max.sampling.interval.
#' @param treedist the type of tree distance metric to use, can be 'PD' for path distance or 'RF' for Robinson Foulds distance
#' @param use.all.samples (TRUE/FALSE). Whether to calculate autocorrelation from all possible pairs of trees in your chain. The default is FALSE, in which case 500 samples are taken at each sampling interval. Setting this to TRUE will give you slightly more accurate ESS estimates, at the cost of potentially much longer execution times.
#'
#' @return A data frame with one row per chain, and columns describing the
#' approximate ESS and the name of the chain.
#'
#' @keywords treespace, tree distance, path distance
#'
#' @export topological.approx.ess
#' @examples
#' \dontrun{
#' data(fungus)
#' topological.approx.ess(fungus, burnin = 20)
#' }
topological.approx.ess <- function(chains, burnin = 0, max.sampling.interval = 100, treedist = 'PD', use.all.samples = FALSE){
chains = check.chains(chains)
if(inherits(chains, "list")){
N = length(chains[[1]]$trees)
} else {
N = length(chains[[1]])
}
if(N-burnin < max.sampling.interval){
warning("Not enough trees to use your chosen max.sampling.interval")
warning("Setting it to 90% of the length of your post-burnin chain instead")
max.sampling.interval = floor((N - burnin) * 0.9)
}
# set them equal, so we get every interval.
autocorr.intervals = max.sampling.interval
print(sprintf("Calculating approximate ESS with sampling intervals from 1 to %d", max.sampling.interval))
autocorr.df = topological.autocorr(chains, burnin, max.sampling.interval, autocorr.intervals, squared = TRUE, treedist = treedist, use.all.samples = use.all.samples)
autocorr.m = estimate.autocorr.m(autocorr.df)
approx.ess.df = approx.ess.multi(autocorr.df, autocorr.m, (N-burnin))
return(approx.ess.df)
}
approx.ess.multi <- function(autocorr.df, autocorr.m, N){
# estimate the approximate ESS from squared topological distances,
# using a single chain
r = length(unique(autocorr.df$chain))
approx.ess.df = data.frame(operator = rep(NA, r), approx.ess = rep(NA, r), chain = unique(autocorr.df$chain))
# Loop over chains, calculate approx ess
for(i in 1:nrow(approx.ess.df)){
thischain = approx.ess.df$chain[i]
thism = autocorr.m$autocorr.time[autocorr.m$chain == thischain]
thisdata = autocorr.df[autocorr.df$chain == thischain,]
ess.info = approx.ess.single(thisdata, thism, N)
ess = ess.info$ess
operator = ess.info$operator
approx.ess.df$approx.ess[approx.ess.df$chain == thischain] = ess
approx.ess.df$operator[approx.ess.df$chain == thischain] = operator
}
return(approx.ess.df)
}
approx.ess.single <- function(df, autocorr.time, N){
# many thanks to Xia Hua and David Bryant for help with this
# if the autocorrelation time is larger than the maximum sample
# our it is recorded as -1
if(autocorr.time < 0){
m = nrow(df) + 1
}else{
m = autocorr.time
}
D = max(df$topo.distance)
S = 0
if(m>1){
for(k in 1:(m - 1)){
f = df$topo.distance[k]
S = S + ((N - k) * f)
}
}
S = S + (N - m + 1) * (N - m) * D / 2
S = S / 2 / N^2
ESS = 1 / (1 - 4 * S / D)
# sometimes we can only give an upper bound
if(autocorr.time<0){
operator = "<"
}else{
operator = "="
}
return(list("ess" = ESS, "operator" = operator))
}
test.output <- analyze.rwty(test.trees, window.size=4, treespace.points=4, autocorr.intervals = 4, max.sampling.interval = 4, burnin=0)
test.trees$trees
#' Calculate the approximate Effective Sample Size (ESS) of tree topologies
#'
#' This function takes a list of rwty.trees objects, and calculates the
#' pseudo ESS of the trees from each chain, after removing burnin.
#' The calculation uses the autocorrelation among squared topological distances between
#' trees to calculate an approximate ESS of tree topologies for each chain.
#' NB this function requires the calculation of many many
#' tree distances, so can take some time.
#'
#' @param chains A list of rwty.trees objects.
#' @param burnin The number of trees to eliminate as burnin
#' @param max.sampling.interval The largest sampling interval you want to use to calculate the ESS. Every sampling interval up to and including this number will be sampled. Higher is better, but also slower. In general, setting this number to 100 (the default) should be fine for most cases. However, if you get an upper bound on the ESS estimate (i.e. ESS<x) rather than a point estimate (i.e. ESS = x) then that indicates a higher max.sampling.interval would be better, because the algorithm could not find the asymptote on the autocorrelation plot with the current max.sampling.interval.
#' @param treedist the type of tree distance metric to use, can be 'PD' for path distance or 'RF' for Robinson Foulds distance
#' @param use.all.samples (TRUE/FALSE). Whether to calculate autocorrelation from all possible pairs of trees in your chain. The default is FALSE, in which case 500 samples are taken at each sampling interval. Setting this to TRUE will give you slightly more accurate ESS estimates, at the cost of potentially much longer execution times.
#'
#' @return A data frame with one row per chain, and columns describing the
#' approximate ESS and the name of the chain.
#'
#' @keywords treespace, tree distance, path distance
#'
#' @export topological.approx.ess
#' @examples
#' \dontrun{
#' data(fungus)
#' topological.approx.ess(fungus, burnin = 20)
#' }
topological.approx.ess <- function(chains, burnin = 0, max.sampling.interval = 100, treedist = 'PD', use.all.samples = FALSE){
chains = check.chains(chains)
if(inherits(chains, "list")){
N = length(chains[[1]]$trees)
} else {
N = length(chains$trees)
}
if(N-burnin < max.sampling.interval){
warning("Not enough trees to use your chosen max.sampling.interval")
warning("Setting it to 90% of the length of your post-burnin chain instead")
max.sampling.interval = floor((N - burnin) * 0.9)
}
# set them equal, so we get every interval.
autocorr.intervals = max.sampling.interval
print(sprintf("Calculating approximate ESS with sampling intervals from 1 to %d", max.sampling.interval))
autocorr.df = topological.autocorr(chains, burnin, max.sampling.interval, autocorr.intervals, squared = TRUE, treedist = treedist, use.all.samples = use.all.samples)
autocorr.m = estimate.autocorr.m(autocorr.df)
approx.ess.df = approx.ess.multi(autocorr.df, autocorr.m, (N-burnin))
return(approx.ess.df)
}
approx.ess.multi <- function(autocorr.df, autocorr.m, N){
# estimate the approximate ESS from squared topological distances,
# using a single chain
r = length(unique(autocorr.df$chain))
approx.ess.df = data.frame(operator = rep(NA, r), approx.ess = rep(NA, r), chain = unique(autocorr.df$chain))
# Loop over chains, calculate approx ess
for(i in 1:nrow(approx.ess.df)){
thischain = approx.ess.df$chain[i]
thism = autocorr.m$autocorr.time[autocorr.m$chain == thischain]
thisdata = autocorr.df[autocorr.df$chain == thischain,]
ess.info = approx.ess.single(thisdata, thism, N)
ess = ess.info$ess
operator = ess.info$operator
approx.ess.df$approx.ess[approx.ess.df$chain == thischain] = ess
approx.ess.df$operator[approx.ess.df$chain == thischain] = operator
}
return(approx.ess.df)
}
approx.ess.single <- function(df, autocorr.time, N){
# many thanks to Xia Hua and David Bryant for help with this
# if the autocorrelation time is larger than the maximum sample
# our it is recorded as -1
if(autocorr.time < 0){
m = nrow(df) + 1
}else{
m = autocorr.time
}
D = max(df$topo.distance)
S = 0
if(m>1){
for(k in 1:(m - 1)){
f = df$topo.distance[k]
S = S + ((N - k) * f)
}
}
S = S + (N - m + 1) * (N - m) * D / 2
S = S / 2 / N^2
ESS = 1 / (1 - 4 * S / D)
# sometimes we can only give an upper bound
if(autocorr.time<0){
operator = "<"
}else{
operator = "="
}
return(list("ess" = ESS, "operator" = operator))
}
test.output <- analyze.rwty(test.trees, window.size=4, treespace.points=4, autocorr.intervals = 4, max.sampling.interval = 4, burnin=0)
#' Calculate the approximate Effective Sample Size (ESS) of tree topologies
#'
#' This function takes a list of rwty.trees objects, and calculates the
#' pseudo ESS of the trees from each chain, after removing burnin.
#' The calculation uses the autocorrelation among squared topological distances between
#' trees to calculate an approximate ESS of tree topologies for each chain.
#' NB this function requires the calculation of many many
#' tree distances, so can take some time.
#'
#' @param chains A list of rwty.trees objects.
#' @param burnin The number of trees to eliminate as burnin
#' @param max.sampling.interval The largest sampling interval you want to use to calculate the ESS. Every sampling interval up to and including this number will be sampled. Higher is better, but also slower. In general, setting this number to 100 (the default) should be fine for most cases. However, if you get an upper bound on the ESS estimate (i.e. ESS<x) rather than a point estimate (i.e. ESS = x) then that indicates a higher max.sampling.interval would be better, because the algorithm could not find the asymptote on the autocorrelation plot with the current max.sampling.interval.
#' @param treedist the type of tree distance metric to use, can be 'PD' for path distance or 'RF' for Robinson Foulds distance
#' @param use.all.samples (TRUE/FALSE). Whether to calculate autocorrelation from all possible pairs of trees in your chain. The default is FALSE, in which case 500 samples are taken at each sampling interval. Setting this to TRUE will give you slightly more accurate ESS estimates, at the cost of potentially much longer execution times.
#'
#' @return A data frame with one row per chain, and columns describing the
#' approximate ESS and the name of the chain.
#'
#' @keywords treespace, tree distance, path distance
#'
#' @export topological.approx.ess
#' @examples
#' \dontrun{
#' data(fungus)
#' topological.approx.ess(fungus, burnin = 20)
#' }
topological.approx.ess <- function(chains, burnin = 0, max.sampling.interval = 100, treedist = 'PD', use.all.samples = FALSE){
chains = check.chains(chains)
if(inherits(chains, "list")){
N = length(chains[[1]]$trees)
} else {
N = length(chains$trees)
}
print(N)
if(N-burnin < max.sampling.interval){
warning("Not enough trees to use your chosen max.sampling.interval")
warning("Setting it to 90% of the length of your post-burnin chain instead")
max.sampling.interval = floor((N - burnin) * 0.9)
}
# set them equal, so we get every interval.
autocorr.intervals = max.sampling.interval
print(sprintf("Calculating approximate ESS with sampling intervals from 1 to %d", max.sampling.interval))
autocorr.df = topological.autocorr(chains, burnin, max.sampling.interval, autocorr.intervals, squared = TRUE, treedist = treedist, use.all.samples = use.all.samples)
autocorr.m = estimate.autocorr.m(autocorr.df)
approx.ess.df = approx.ess.multi(autocorr.df, autocorr.m, (N-burnin))
return(approx.ess.df)
}
approx.ess.multi <- function(autocorr.df, autocorr.m, N){
# estimate the approximate ESS from squared topological distances,
# using a single chain
r = length(unique(autocorr.df$chain))
approx.ess.df = data.frame(operator = rep(NA, r), approx.ess = rep(NA, r), chain = unique(autocorr.df$chain))
# Loop over chains, calculate approx ess
for(i in 1:nrow(approx.ess.df)){
thischain = approx.ess.df$chain[i]
thism = autocorr.m$autocorr.time[autocorr.m$chain == thischain]
thisdata = autocorr.df[autocorr.df$chain == thischain,]
ess.info = approx.ess.single(thisdata, thism, N)
ess = ess.info$ess
operator = ess.info$operator
approx.ess.df$approx.ess[approx.ess.df$chain == thischain] = ess
approx.ess.df$operator[approx.ess.df$chain == thischain] = operator
}
return(approx.ess.df)
}
approx.ess.single <- function(df, autocorr.time, N){
# many thanks to Xia Hua and David Bryant for help with this
# if the autocorrelation time is larger than the maximum sample
# our it is recorded as -1
if(autocorr.time < 0){
m = nrow(df) + 1
}else{
m = autocorr.time
}
D = max(df$topo.distance)
S = 0
if(m>1){
for(k in 1:(m - 1)){
f = df$topo.distance[k]
S = S + ((N - k) * f)
}
}
S = S + (N - m + 1) * (N - m) * D / 2
S = S / 2 / N^2
ESS = 1 / (1 - 4 * S / D)
# sometimes we can only give an upper bound
if(autocorr.time<0){
operator = "<"
}else{
operator = "="
}
return(list("ess" = ESS, "operator" = operator))
}
test.output <- analyze.rwty(test.trees, window.size=4, treespace.points=4, autocorr.intervals = 4, max.sampling.interval = 4, burnin=0)
